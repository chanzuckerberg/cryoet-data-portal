"""CryoET data portal client model classes.

Auto-generated by running 'make codegen'. Do not edit.
Edit the Jinja2 templates instead.
"""

from __future__ import annotations

import os
from datetime import date
from typing import Iterable, List, Optional

from cryoet_data_portal._client import Client
from cryoet_data_portal._file_tools import download_directory, download_https
from cryoet_data_portal._gql_base import (
    BooleanField,
    DateField,
    FloatField,
    GQLExpression,
    IntField,
    ItemRelationship,
    ListField,
    ListRelationship,
    Model,
    StringField,
)


class Alignment(Model):
    """Tiltseries Alignment

    Attributes:
        id (int): Numeric identifier (May change!)
        annotation_files (List[AnnotationFile]): The annotation files of this alignment
        per_section_alignments (List[PerSectionAlignmentParameters]): The per section alignment parameters of this alignment
        deposition (Deposition): The deposition this alignment is a part of
        deposition_id (int): None
        tiltseries (TiltSeries): The tilt series this alignment is a part of
        tiltseries_id (int): None
        tomograms (List[Tomogram]): The tomograms of this alignment
        run (Run): The run this alignment is a part of
        run_id (int): None
        alignment_type (str): Whether this a LOCAL or GLOBAL alignment
        alignment_method (str): The method used to create this alignment
        volume_x_dimension (float): X dimension of the reconstruction volume in angstrom
        volume_y_dimension (float): Y dimension of the reconstruction volume in angstrom
        volume_z_dimension (float): Z dimension of the reconstruction volume in angstrom
        volume_x_offset (float): X shift of the reconstruction volume in angstrom
        volume_y_offset (float): Y shift of the reconstruction volume in angstrom
        volume_z_offset (float): Z shift of the reconstruction volume in angstrom
        x_rotation_offset (float): Additional X rotation of the reconstruction volume in degrees
        tilt_offset (float): Additional tilt offset in degrees
        affine_transformation_matrix (str): A placeholder for the affine transformation matrix.
        s3_alignment_metadata (str): S3 path to the metadata file for this alignment
        https_alignment_metadata (str): HTTPS url to the metadata file for this alignment
        is_portal_standard (bool): Whether this is the portal standard alignment
    """

    _gql_type: str = "Alignment"
    _gql_root_field: str = "alignments"

    id: int = IntField()
    annotation_files: List[AnnotationFile] = ListRelationship(
        "AnnotationFile",
        "id",
        "alignment_id",
    )
    per_section_alignments: List[PerSectionAlignmentParameters] = ListRelationship(
        "PerSectionAlignmentParameters",
        "id",
        "alignment_id",
    )
    deposition: Deposition = ItemRelationship("Deposition", "deposition_id", "id")
    deposition_id: int = IntField()
    tiltseries: TiltSeries = ItemRelationship("TiltSeries", "tiltseries_id", "id")
    tiltseries_id: int = IntField()
    tomograms: List[Tomogram] = ListRelationship("Tomogram", "id", "alignment_id")
    run: Run = ItemRelationship("Run", "run_id", "id")
    run_id: int = IntField()
    alignment_type: str = StringField()
    alignment_method: str = StringField()
    volume_x_dimension: float = FloatField()
    volume_y_dimension: float = FloatField()
    volume_z_dimension: float = FloatField()
    volume_x_offset: float = FloatField()
    volume_y_offset: float = FloatField()
    volume_z_offset: float = FloatField()
    x_rotation_offset: float = FloatField()
    tilt_offset: float = FloatField()
    affine_transformation_matrix: str = StringField()
    s3_alignment_metadata: str = StringField()
    https_alignment_metadata: str = StringField()
    is_portal_standard: bool = BooleanField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:
            >>> alignments = Alignment.find(client, query_filters=[Alignment.run.name == "TS_026"])

            Get all results for this type:

            >>> alignments = Alignment.find(client)
        """
        return super(Alignment, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an Alignment by ID:

            >>> alignment = Alignment.get_by_id(client, 1)
            >>> print(alignment.id)
        """
        return super(Alignment, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )


class Annotation(Model):
    """Metadata for an annotation

    Attributes:
        id (int): Numeric identifier (May change!)
        run (Run): The run this annotation is a part of
        run_id (int): None
        annotation_shapes (List[AnnotationShape]): The annotation shapes of this annotation
        method_links (List[AnnotationMethodLink]): The annotation method links of this annotation
        authors (List[AnnotationAuthor]): The annotation authors of this annotation
        deposition (Deposition): The deposition this annotation is a part of
        deposition_id (int): None
        s3_metadata_path (str): S3 path for the metadata json file for this annotation
        https_metadata_path (str): HTTPS path for the metadata json file for this annotation
        annotation_publication (str): DOIs for publications that describe the dataset. Use a comma to separate multiple DOIs.
        annotation_method (str): Describe how the annotation is made (e.g. Manual, crYoLO, Positive Unlabeled Learning, template matching)
        ground_truth_status (bool): Whether an annotation is considered ground truth, as determined by the annotator.
        object_id (str): Gene Ontology Cellular Component identifier or UniProtKB accession for the annotation object.
        object_name (str): Name of the object being annotated (e.g. ribosome, nuclear pore complex, actin filament, membrane)
        object_description (str): A textual description of the annotation object, can be a longer description to include additional information not covered by the Annotation object name and state.
        object_state (str): Molecule state annotated (e.g. open, closed)
        object_count (int): Number of objects identified
        confidence_precision (float): Describe the confidence level of the annotation. Precision is defined as the % of annotation objects being true positive
        confidence_recall (float): Describe the confidence level of the annotation. Recall is defined as the % of true positives being annotated correctly
        ground_truth_used (str): Annotation filename used as ground truth for precision and recall
        annotation_software (str): Software used for generating this annotation
        is_curator_recommended (bool): Data curator’s subjective choice as the best annotation of the same annotation object ID
        method_type (str): The method type for generating the annotation (e.g. manual, hybrid, automated)
        deposition_date (date): Date when an annotation set is initially received by the Data Portal.
        release_date (date): Date when annotation data is made public by the Data Portal.
        last_modified_date (date): Date when an annotation was last modified in the Data Portal
    """

    _gql_type: str = "Annotation"
    _gql_root_field: str = "annotations"

    id: int = IntField()
    run: Run = ItemRelationship("Run", "run_id", "id")
    run_id: int = IntField()
    annotation_shapes: List[AnnotationShape] = ListRelationship(
        "AnnotationShape",
        "id",
        "annotation_id",
    )
    method_links: List[AnnotationMethodLink] = ListRelationship(
        "AnnotationMethodLink",
        "id",
        "annotation_id",
    )
    authors: List[AnnotationAuthor] = ListRelationship(
        "AnnotationAuthor",
        "id",
        "annotation_id",
    )
    deposition: Deposition = ItemRelationship("Deposition", "deposition_id", "id")
    deposition_id: int = IntField()
    s3_metadata_path: str = StringField()
    https_metadata_path: str = StringField()
    annotation_publication: str = StringField()
    annotation_method: str = StringField()
    ground_truth_status: bool = BooleanField()
    object_id: str = StringField()
    object_name: str = StringField()
    object_description: str = StringField()
    object_state: str = StringField()
    object_count: int = IntField()
    confidence_precision: float = FloatField()
    confidence_recall: float = FloatField()
    ground_truth_used: str = StringField()
    annotation_software: str = StringField()
    is_curator_recommended: bool = BooleanField()
    method_type: str = StringField()
    deposition_date: date = DateField()
    release_date: date = DateField()
    last_modified_date: date = DateField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:
            >>> annotations = Annotation.find(client, query_filters=[Annotation.run.name == "TS_026"])

            Get all results for this type:

            >>> annotations = Annotation.find(client)
        """
        return super(Annotation, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an Annotation by ID:

            >>> annotation = Annotation.get_by_id(client, 1)
            >>> print(annotation.id)
        """
        return super(Annotation, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )

    def download_metadata(
        self,
        dest_path: Optional[str] = None,
    ):
        """Download annotation metadata

        Args:
            dest_path (Optional[str], optional): Choose a destination directory. Defaults to $CWD.
        """
        download_https(self.https_metadata_path, dest_path)

    def download(
        self,
        dest_path: Optional[str] = None,
        format: Optional[str] = None,
        shape: Optional[str] = None,
    ):
        """Download annotation files for a given format and/or shape

        Args:
            dest_path (Optional[str], optional): Choose a destination directory. Defaults to $CWD.
            shape (Optional[str], optional): Choose a specific shape type to download (e.g.: OrientedPoint, SegmentationMask)
            format (Optional[str], optional): Choose a specific file format to download (e.g.: mrc, ndjson)
        """
        download_metadata = False
        for anno_shape in self.annotation_shapes:
            if shape and anno_shape.shape_type != shape:
                continue
            for file in anno_shape.annotation_files:
                if format and file.format != format:
                    continue
                file.download(dest_path)
                download_metadata = True
        if download_metadata:
            self.download_metadata(dest_path)


class AnnotationAuthor(Model):
    """Metadata for an annotation's authors

    Attributes:
        id (int): Numeric identifier (May change!)
        annotation (Annotation): The annotation this annotation author is a part of
        annotation_id (int): None
        author_list_order (int): The order in which the author appears in the publication
        orcid (str): A unique, persistent identifier for researchers, provided by ORCID.
        kaggle_id (str): A unique, persistent identifier for kaggle users at kaggle.com.
        name (str): Full name of an annotation author (e.g. Jane Doe).
        email (str): Email address for this author
        affiliation_name (str): Name of the institution an annotator is affiliated with. Sometimes, one annotator may have multiple affiliations.
        affiliation_address (str): Address of the institution an annotator is affiliated with.
        affiliation_identifier (str): A unique identifier assigned to the affiliated institution by The Research Organization Registry (ROR).
        corresponding_author_status (bool): Indicates whether an annotator is the corresponding author
        primary_author_status (bool): Indicates whether an author is the main person executing the annotation, especially on manual annotation
    """

    _gql_type: str = "AnnotationAuthor"
    _gql_root_field: str = "annotationAuthors"

    id: int = IntField()
    annotation: Annotation = ItemRelationship("Annotation", "annotation_id", "id")
    annotation_id: int = IntField()
    author_list_order: int = IntField()
    orcid: str = StringField()
    kaggle_id: str = StringField()
    name: str = StringField()
    email: str = StringField()
    affiliation_name: str = StringField()
    affiliation_address: str = StringField()
    affiliation_identifier: str = StringField()
    corresponding_author_status: bool = BooleanField()
    primary_author_status: bool = BooleanField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:
            >>> annotation_authors = AnnotationAuthor.find(client, query_filters=[AnnotationAuthor.annotation.run.name._in(['TS_026', 'TS_027']), AnnotationAuthor.annotation.object_name.ilike('%membrane%')])

            Get all results for this type:

            >>> annotation_authors = AnnotationAuthor.find(client)
        """
        return super(AnnotationAuthor, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an AnnotationAuthor by ID:

            >>> annotation_author = AnnotationAuthor.get_by_id(client, 1)
            >>> print(annotation_author.name)
        """
        return super(AnnotationAuthor, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )


class AnnotationFile(Model):
    """Metadata for files associated with an annotation

    Attributes:
        id (int): Numeric identifier (May change!)
        alignment (Alignment): The alignment this annotation file is a part of
        alignment_id (int): None
        annotation_shape (AnnotationShape): The annotation shape this annotation file is a part of
        annotation_shape_id (int): None
        tomogram_voxel_spacing (TomogramVoxelSpacing): The tomogram voxel spacing this annotation file is a part of
        tomogram_voxel_spacing_id (int): None
        format (str): File format for this file
        s3_path (str): s3 path of the annotation file
        file_size (float): Size of annota file in bytes
        https_path (str): HTTPS path for this annotation file
        is_visualization_default (bool): Data curator’s subjective choice of default annotation to display in visualization for an object
        source (str): The source type for the annotation file (dataset_author, community, or portal_standard)
    """

    _gql_type: str = "AnnotationFile"
    _gql_root_field: str = "annotationFiles"

    id: int = IntField()
    alignment: Alignment = ItemRelationship("Alignment", "alignment_id", "id")
    alignment_id: int = IntField()
    annotation_shape: AnnotationShape = ItemRelationship(
        "AnnotationShape",
        "annotation_shape_id",
        "id",
    )
    annotation_shape_id: int = IntField()
    tomogram_voxel_spacing: TomogramVoxelSpacing = ItemRelationship(
        "TomogramVoxelSpacing",
        "tomogram_voxel_spacing_id",
        "id",
    )
    tomogram_voxel_spacing_id: int = IntField()
    format: str = StringField()
    s3_path: str = StringField()
    file_size: float = FloatField()
    https_path: str = StringField()
    is_visualization_default: bool = BooleanField()
    source: str = StringField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:

            Get all results for this type:

            >>> annotation_files = AnnotationFile.find(client)
        """
        return super(AnnotationFile, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an AnnotationFile by ID:

            >>> annotation_file = AnnotationFile.get_by_id(client, 1)
            >>> print(annotation_file.id)
        """
        return super(AnnotationFile, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )

    def download(self, dest_path: Optional[str] = None):
        if self.format == "zarr":
            recursive_prefix = "/".join(self.s3_path.split("/")[:-1]) + "/"
            download_directory(self.s3_path, recursive_prefix, dest_path)
        else:
            download_https(self.https_path, dest_path)


class AnnotationMethodLink(Model):
    """A set of links to models, source code, documentation, etc referenced by annotation method

    Attributes:
        id (int): Numeric identifier (May change!)
        annotation (Annotation): The annotation this annotation method link is a part of
        annotation_id (int): None
        link_type (str): Type of link (e.g. model, source code, documentation)
        name (str): user readable name of the resource
        link (str): URL to the resource
    """

    _gql_type: str = "AnnotationMethodLink"
    _gql_root_field: str = "annotationMethodLinks"

    id: int = IntField()
    annotation: Annotation = ItemRelationship("Annotation", "annotation_id", "id")
    annotation_id: int = IntField()
    link_type: str = StringField()
    name: str = StringField()
    link: str = StringField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:
            >>> annotation_method_links = AnnotationMethodLink.find(client, query_filters=[AnnotationMethodLink.annotation.run.name._in(['TS_026', 'TS_027']), AnnotationMethodLink.annotation.object_name.ilike('%membrane%')])

            Get all results for this type:

            >>> annotation_method_links = AnnotationMethodLink.find(client)
        """
        return super(AnnotationMethodLink, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an AnnotationMethodLink by ID:

            >>> annotation_method_link = AnnotationMethodLink.get_by_id(client, 1)
            >>> print(annotation_method_link.name)
        """
        return super(AnnotationMethodLink, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )


class AnnotationShape(Model):
    """Shapes associated with an annotation

    Attributes:
        id (int): Numeric identifier (May change!)
        annotation (Annotation): The annotation this annotation shape is a part of
        annotation_id (int): None
        annotation_files (List[AnnotationFile]): The annotation files of this annotation shape
        shape_type (str): The shape of the annotation (SegmentationMask, OrientedPoint, Point, InstanceSegmentation, Mesh)
    """

    _gql_type: str = "AnnotationShape"
    _gql_root_field: str = "annotationShapes"

    id: int = IntField()
    annotation: Annotation = ItemRelationship("Annotation", "annotation_id", "id")
    annotation_id: int = IntField()
    annotation_files: List[AnnotationFile] = ListRelationship(
        "AnnotationFile",
        "id",
        "annotation_shape_id",
    )
    shape_type: str = StringField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:
            >>> annotation_shapes = AnnotationShape.find(client, query_filters=[AnnotationShape.annotation.run.name._in(['TS_026', 'TS_027']), AnnotationShape.annotation.object_name.ilike('%membrane%')])

            Get all results for this type:

            >>> annotation_shapes = AnnotationShape.find(client)
        """
        return super(AnnotationShape, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an AnnotationShape by ID:

            >>> annotation_shape = AnnotationShape.get_by_id(client, 1)
            >>> print(annotation_shape.id)
        """
        return super(AnnotationShape, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )


class Dataset(Model):
    """A collection of imaging experiments on the same organism

    Attributes:
        id (int): An identifier for a CryoET dataset, assigned by the Data Portal. Used to identify the dataset as the directory name in data tree
        deposition (Deposition): The deposition this dataset is a part of
        deposition_id (int): None
        funding_sources (List[DatasetFunding]): The dataset fundings of this dataset
        authors (List[DatasetAuthor]): The dataset authors of this dataset
        runs (List[Run]): The runs of this dataset
        title (str): Title of a CryoET dataset
        description (str): A short description of a CryoET dataset, similar to an abstract for a journal article or dataset.
        organism_name (str): Name of the organism from which a biological sample used in a CryoET study is derived from, e.g. homo sapiens
        organism_taxid (int): NCBI taxonomy identifier for the organism, e.g. 9606
        tissue_name (str): Name of the tissue from which a biological sample used in a CryoET study is derived from.
        tissue_id (str): UBERON identifier for the tissue
        cell_name (str): Name of the cell from which a biological sample used in a CryoET study is derived from.
        cell_type_id (str): Cell Ontology identifier for the cell type
        cell_strain_name (str): Cell line or strain for the sample.
        cell_strain_id (str): Link to more information about the cell strain
        sample_type (str): Type of samples used in a CryoET study. (cell, tissue, organism, intact organelle, in-vitro mixture, in-silico synthetic data, other)
        sample_preparation (str): Describe how the sample was prepared.
        grid_preparation (str): Describe Cryo-ET grid preparation.
        other_setup (str): Describe other setup not covered by sample preparation or grid preparation that may make this dataset unique in the same publication
        key_photo_url (str): URL for the dataset preview image.
        key_photo_thumbnail_url (str): URL for the thumbnail of preview image.
        cell_component_name (str): Name of the cellular component
        cell_component_id (str): If the dataset focuses on a specific part of a cell, the subset is included here
        deposition_date (date): Date when a dataset is initially received by the Data Portal.
        release_date (date): Date when a dataset is made available on the Data Portal.
        last_modified_date (date): Date when a released dataset is last modified.
        dataset_publications (str): Comma-separated list of DOIs for publications associated with the dataset.
        related_database_entries (str): If a CryoET dataset is also deposited into another database, enter the database identifier here (e.g. EMPIAR-11445). Use a comma to separate multiple identifiers.
        s3_prefix (str): The S3 public bucket path where this dataset is contained
        https_prefix (str): The https directory path where this dataset is contained
        file_size (float): Size of the dataset in bytes
    """

    _gql_type: str = "Dataset"
    _gql_root_field: str = "datasets"

    id: int = IntField()
    deposition: Deposition = ItemRelationship("Deposition", "deposition_id", "id")
    deposition_id: int = IntField()
    funding_sources: List[DatasetFunding] = ListRelationship(
        "DatasetFunding",
        "id",
        "dataset_id",
    )
    authors: List[DatasetAuthor] = ListRelationship("DatasetAuthor", "id", "dataset_id")
    runs: List[Run] = ListRelationship("Run", "id", "dataset_id")
    title: str = StringField()
    description: str = StringField()
    organism_name: str = StringField()
    organism_taxid: int = IntField()
    tissue_name: str = StringField()
    tissue_id: str = StringField()
    cell_name: str = StringField()
    cell_type_id: str = StringField()
    cell_strain_name: str = StringField()
    cell_strain_id: str = StringField()
    sample_type: str = StringField()
    sample_preparation: str = StringField()
    grid_preparation: str = StringField()
    other_setup: str = StringField()
    key_photo_url: str = StringField()
    key_photo_thumbnail_url: str = StringField()
    cell_component_name: str = StringField()
    cell_component_id: str = StringField()
    deposition_date: date = DateField()
    release_date: date = DateField()
    last_modified_date: date = DateField()
    dataset_publications: str = StringField()
    related_database_entries: str = StringField()
    s3_prefix: str = StringField()
    https_prefix: str = StringField()
    file_size: float = FloatField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:

            Get all results for this type:

            >>> datasets = Dataset.find(client)
        """
        return super(Dataset, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an Dataset by ID:

            >>> dataset = Dataset.get_by_id(client, 1)
            >>> print(dataset.id)
        """
        return super(Dataset, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )

    def download_everything(self, dest_path: Optional[str] = None):
        """Download all of the data for this dataset.

        Args:
            dest_path (Optional[str], optional): Choose a destination directory. Defaults to $CWD.
        """
        recursive_prefix = "/".join(self.s3_prefix.strip("/").split("/")[:-1]) + "/"
        download_directory(self.s3_prefix, recursive_prefix, dest_path)


class DatasetAuthor(Model):
    """An author of a dataset

    Attributes:
        id (int): Numeric identifier (May change!)
        dataset (Dataset): The dataset this dataset author is a part of
        dataset_id (int): None
        author_list_order (int): The order in which the author appears in the publication
        orcid (str): A unique, persistent identifier for researchers, provided by ORCID.
        kaggle_id (str): A unique, persistent identifier for kaggle users at kaggle.com.
        name (str): Full name of a dataset author (e.g. Jane Doe).
        email (str): Email address for this author
        affiliation_name (str): Name of the institutions an author is affiliated with. Comma separated
        affiliation_address (str): Address of the institution an author is affiliated with.
        affiliation_identifier (str): A unique identifier assigned to the affiliated institution by The Research Organization Registry (ROR).
        corresponding_author_status (bool): Indicates whether an author is the corresponding author
        primary_author_status (bool): Indicates whether an author is the main person associated with the corresponding dataset
    """

    _gql_type: str = "DatasetAuthor"
    _gql_root_field: str = "datasetAuthors"

    id: int = IntField()
    dataset: Dataset = ItemRelationship("Dataset", "dataset_id", "id")
    dataset_id: int = IntField()
    author_list_order: int = IntField()
    orcid: str = StringField()
    kaggle_id: str = StringField()
    name: str = StringField()
    email: str = StringField()
    affiliation_name: str = StringField()
    affiliation_address: str = StringField()
    affiliation_identifier: str = StringField()
    corresponding_author_status: bool = BooleanField()
    primary_author_status: bool = BooleanField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:
            Filter dataset authors by attributes, including attributes in related models:

            >>> dataset_authors = DatasetAuthor.find(client, query_filters=[DatasetAuthor.name == "TS_026", DatasetAuthor.dataset.id == 10000])

            Get all results for this type:

            >>> dataset_authors = DatasetAuthor.find(client)
        """
        return super(DatasetAuthor, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an DatasetAuthor by ID:

            >>> dataset_author = DatasetAuthor.get_by_id(client, 1)
            >>> print(dataset_author.name)
        """
        return super(DatasetAuthor, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )


class DatasetFunding(Model):
    """Metadata for a dataset's funding sources

    Attributes:
        id (int): Numeric identifier (May change!)
        dataset (Dataset): The dataset this dataset funding is a part of
        dataset_id (int): None
        funding_agency_name (str): Name of the funding agency.
        grant_id (str): Grant identifier provided by the funding agency.
    """

    _gql_type: str = "DatasetFunding"
    _gql_root_field: str = "datasetFunding"

    id: int = IntField()
    dataset: Dataset = ItemRelationship("Dataset", "dataset_id", "id")
    dataset_id: int = IntField()
    funding_agency_name: str = StringField()
    grant_id: str = StringField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:
            Filter dataset fundings by attributes, including attributes in related models:

            >>> dataset_fundings = DatasetFunding.find(client, query_filters=[DatasetFunding.dataset.id == 10000])

            Get all results for this type:

            >>> dataset_fundings = DatasetFunding.find(client)
        """
        return super(DatasetFunding, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an DatasetFunding by ID:

            >>> dataset_funding = DatasetFunding.get_by_id(client, 1)
            >>> print(dataset_funding.id)
        """
        return super(DatasetFunding, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )


class Deposition(Model):
    """Deposition metadata

    Attributes:
        id (int): Numeric identifier (May change!)
        authors (List[DepositionAuthor]): The deposition authors of this deposition
        alignments (List[Alignment]): The alignments of this deposition
        annotations (List[Annotation]): The annotations of this deposition
        datasets (List[Dataset]): The datasets of this deposition
        frames (List[Frame]): The frames of this deposition
        tiltseries (List[TiltSeries]): The tilt series of this deposition
        tomograms (List[Tomogram]): The tomograms of this deposition
        title (str): Title for the deposition
        description (str): Description for the deposition
        tag (str): Tag for the deposition - like ml competition
        deposition_types (List[DepositionType]): The deposition types of this deposition
        deposition_publications (str): The publications related to this deposition
        related_database_entries (str): The related database entries to this deposition
        deposition_date (date): The date the deposition was deposited
        release_date (date): The date the deposition was released
        last_modified_date (date): The date the deposition was last modified
        key_photo_url (str): URL for the deposition preview image.
        key_photo_thumbnail_url (str): URL for the deposition thumbnail image.
    """

    _gql_type: str = "Deposition"
    _gql_root_field: str = "depositions"

    id: int = IntField()
    authors: List[DepositionAuthor] = ListRelationship(
        "DepositionAuthor",
        "id",
        "deposition_id",
    )
    alignments: List[Alignment] = ListRelationship("Alignment", "id", "deposition_id")
    annotations: List[Annotation] = ListRelationship(
        "Annotation",
        "id",
        "deposition_id",
    )
    datasets: List[Dataset] = ListRelationship("Dataset", "id", "deposition_id")
    frames: List[Frame] = ListRelationship("Frame", "id", "deposition_id")
    tiltseries: List[TiltSeries] = ListRelationship("TiltSeries", "id", "deposition_id")
    tomograms: List[Tomogram] = ListRelationship("Tomogram", "id", "deposition_id")
    title: str = StringField()
    description: str = StringField()
    tag: str = StringField()
    deposition_types: List[DepositionType] = ListRelationship(
        "DepositionType",
        "id",
        "deposition_id",
    )
    deposition_publications: str = StringField()
    related_database_entries: str = StringField()
    deposition_date: date = DateField()
    release_date: date = DateField()
    last_modified_date: date = DateField()
    key_photo_url: str = StringField()
    key_photo_thumbnail_url: str = StringField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:

            Get all results for this type:

            >>> depositions = Deposition.find(client)
        """
        return super(Deposition, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an Deposition by ID:

            >>> deposition = Deposition.get_by_id(client, 1)
            >>> print(deposition.id)
        """
        return super(Deposition, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )


class DepositionAuthor(Model):
    """Authors for a deposition

    Attributes:
        id (int): Numeric identifier (May change!)
        deposition (Deposition): The deposition this deposition author is a part of
        deposition_id (int): None
        author_list_order (int): The order in which the author appears in the publication
        orcid (str): A unique, persistent identifier for researchers, provided by ORCID.
        kaggle_id (str): A unique, persistent identifier for kaggle users at kaggle.com.
        name (str): Full name of a deposition author (e.g. Jane Doe).
        email (str): Email address for this author
        affiliation_name (str): Name of the institutions an author is affiliated with. Comma separated
        affiliation_address (str): Address of the institution an author is affiliated with.
        affiliation_identifier (str): A unique identifier assigned to the affiliated institution by The Research Organization Registry (ROR).
        corresponding_author_status (bool): Indicates whether an author is the corresponding author
        primary_author_status (bool): Indicates whether an author is the main person creating the deposition
    """

    _gql_type: str = "DepositionAuthor"
    _gql_root_field: str = "depositionAuthors"

    id: int = IntField()
    deposition: Deposition = ItemRelationship("Deposition", "deposition_id", "id")
    deposition_id: int = IntField()
    author_list_order: int = IntField()
    orcid: str = StringField()
    kaggle_id: str = StringField()
    name: str = StringField()
    email: str = StringField()
    affiliation_name: str = StringField()
    affiliation_address: str = StringField()
    affiliation_identifier: str = StringField()
    corresponding_author_status: bool = BooleanField()
    primary_author_status: bool = BooleanField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:

            Get all results for this type:

            >>> deposition_authors = DepositionAuthor.find(client)
        """
        return super(DepositionAuthor, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an DepositionAuthor by ID:

            >>> deposition_author = DepositionAuthor.get_by_id(client, 1)
            >>> print(deposition_author.name)
        """
        return super(DepositionAuthor, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )


class DepositionType(Model):
    """None

    Attributes:
        id (int): Numeric identifier (May change!)
        deposition (Deposition): The deposition this deposition type is a part of
        deposition_id (int): None
        type (str): The type of data submitted as a part of this deposition (annotation, dataset, tomogram)
    """

    _gql_type: str = "DepositionType"
    _gql_root_field: str = "depositionTypes"

    id: int = IntField()
    deposition: Deposition = ItemRelationship("Deposition", "deposition_id", "id")
    deposition_id: int = IntField()
    type: str = StringField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:

            Get all results for this type:

            >>> deposition_types = DepositionType.find(client)
        """
        return super(DepositionType, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an DepositionType by ID:

            >>> deposition_type = DepositionType.get_by_id(client, 1)
            >>> print(deposition_type.id)
        """
        return super(DepositionType, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )


class Frame(Model):
    """None

    Attributes:
        id (int): Numeric identifier (May change!)
        deposition (Deposition): The deposition this frame is a part of
        deposition_id (int): None
        run (Run): The run this frame is a part of
        run_id (int): None
        acquisition_order (int): Frame's acquistion order within a tilt experiment
        accumulated_dose (float): The total accumulated dose exposure frame
        exposure_dose (float): The dose exposure of this frame
        is_gain_corrected (bool): Whether this frame has been gain corrected
        per_section_parameters (List[PerSectionParameters]): The per section parameters of this frame
        s3_frame_path (str): S3 path to the frame file
        https_frame_path (str): HTTPS path to the frame file
        file_size (float): Size of the frame file in bytes
    """

    _gql_type: str = "Frame"
    _gql_root_field: str = "frames"

    id: int = IntField()
    deposition: Deposition = ItemRelationship("Deposition", "deposition_id", "id")
    deposition_id: int = IntField()
    run: Run = ItemRelationship("Run", "run_id", "id")
    run_id: int = IntField()
    acquisition_order: int = IntField()
    accumulated_dose: float = FloatField()
    exposure_dose: float = FloatField()
    is_gain_corrected: bool = BooleanField()
    per_section_parameters: List[PerSectionParameters] = ListRelationship(
        "PerSectionParameters",
        "id",
        "frame_id",
    )
    s3_frame_path: str = StringField()
    https_frame_path: str = StringField()
    file_size: float = FloatField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:
            >>> frames = Frame.find(client, query_filters=[Frame.run.name == "TS_026"])

            Get all results for this type:

            >>> frames = Frame.find(client)
        """
        return super(Frame, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an Frame by ID:

            >>> frame = Frame.get_by_id(client, 1)
            >>> print(frame.id)
        """
        return super(Frame, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )


class FrameAcquisitionFile(Model):
    """References to files containing more information about frame acquisition

    Attributes:
        id (int): Numeric identifier (May change!)
        run (Run): The run this frame acquisition file is a part of
        run_id (int): None
        s3_mdoc_path (str): Path to the frame acquisition mdoc file in s3
        https_mdoc_path (str): Path to the frame acquisition mdoc file as an https url
    """

    _gql_type: str = "FrameAcquisitionFile"
    _gql_root_field: str = "frameAcquisitionFiles"

    id: int = IntField()
    run: Run = ItemRelationship("Run", "run_id", "id")
    run_id: int = IntField()
    s3_mdoc_path: str = StringField()
    https_mdoc_path: str = StringField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:
            >>> frame_acquisition_files = FrameAcquisitionFile.find(client, query_filters=[FrameAcquisitionFile.run.name == "TS_026"])

            Get all results for this type:

            >>> frame_acquisition_files = FrameAcquisitionFile.find(client)
        """
        return super(FrameAcquisitionFile, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an FrameAcquisitionFile by ID:

            >>> frame_acquisition_file = FrameAcquisitionFile.get_by_id(client, 1)
            >>> print(frame_acquisition_file.id)
        """
        return super(FrameAcquisitionFile, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )


class GainFile(Model):
    """Gain values for frames in this run

    Attributes:
        id (int): Numeric identifier (May change!)
        run (Run): The run this gain file is a part of
        run_id (int): None
        s3_file_path (str): Path to the file in s3
        https_file_path (str): Path to the file as an https url
    """

    _gql_type: str = "GainFile"
    _gql_root_field: str = "gainFiles"

    id: int = IntField()
    run: Run = ItemRelationship("Run", "run_id", "id")
    run_id: int = IntField()
    s3_file_path: str = StringField()
    https_file_path: str = StringField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:
            >>> gain_files = GainFile.find(client, query_filters=[GainFile.run.name == "TS_026"])

            Get all results for this type:

            >>> gain_files = GainFile.find(client)
        """
        return super(GainFile, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an GainFile by ID:

            >>> gain_file = GainFile.get_by_id(client, 1)
            >>> print(gain_file.id)
        """
        return super(GainFile, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )


class PerSectionAlignmentParameters(Model):
    """Map alignment parameters to tilt series frames

    Attributes:
        id (int): Numeric identifier (May change!)
        alignment (Alignment): The alignment this per section alignment parameters is a part of
        alignment_id (int): None
        z_index (int): z-index of the frame in the tiltseries
        x_offset (float): In-plane X-shift of the projection in angstrom
        y_offset (float): In-plane Y-shift of the projection in angstrom
        volume_x_rotation (float): X-axis rotation in degrees
        in_plane_rotation (List[List[float]]): In-plane rotation of the projection in degrees
        tilt_angle (float): Tilt angle of the projection in degrees
    """

    _gql_type: str = "PerSectionAlignmentParameters"
    _gql_root_field: str = "perSectionAlignmentParameters"

    id: int = IntField()
    alignment: Alignment = ItemRelationship("Alignment", "alignment_id", "id")
    alignment_id: int = IntField()
    z_index: int = IntField()
    x_offset: float = FloatField()
    y_offset: float = FloatField()
    volume_x_rotation: float = FloatField()
    in_plane_rotation: List[List[float]] = ListField()
    tilt_angle: float = FloatField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:

            Get all results for this type:

            >>> per_section_alignment_parameters = PerSectionAlignmentParameters.find(client)
        """
        return super(PerSectionAlignmentParameters, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an PerSectionAlignmentParameters by ID:

            >>> per_section_alignment_parameters = PerSectionAlignmentParameters.get_by_id(client, 1)
            >>> print(per_section_alignment_parameters.id)
        """
        return super(PerSectionAlignmentParameters, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )


class PerSectionParameters(Model):
    """Map individual Frames to a Tiltseries

    Attributes:
        id (int): Numeric identifier (May change!)
        astigmatic_angle (float): Angle (in degrees) from reciprocal space X axis to the major axis of defocus.
        frame (Frame): The frame this per section parameters is a part of
        frame_id (int): None
        major_defocus (float): Defocus (major axis) estimated for this tilt image in Angstrom (underfocus has positive sign).
        max_resolution (float): Maximum resolution of the frame
        minor_defocus (float): Defocus (minor axis) estimated for this tilt image in Angstrom (underfocus has positive sign).
        phase_shift (float): Phase shift estimated for this tilt image in degrees.
        raw_angle (float): Nominal tilt angle for this tilt image reported by the microscope.
        run (Run): The run this per section parameters is a part of
        run_id (int): None
        tiltseries (TiltSeries): The tilt series this per section parameters is a part of
        tiltseries_id (int): None
        z_index (int): Index (0-based) of this tilt image in the tilt series stack.
    """

    _gql_type: str = "PerSectionParameters"
    _gql_root_field: str = "perSectionParameters"

    id: int = IntField()
    astigmatic_angle: float = FloatField()
    frame: Frame = ItemRelationship("Frame", "frame_id", "id")
    frame_id: int = IntField()
    major_defocus: float = FloatField()
    max_resolution: float = FloatField()
    minor_defocus: float = FloatField()
    phase_shift: float = FloatField()
    raw_angle: float = FloatField()
    run: Run = ItemRelationship("Run", "run_id", "id")
    run_id: int = IntField()
    tiltseries: TiltSeries = ItemRelationship("TiltSeries", "tiltseries_id", "id")
    tiltseries_id: int = IntField()
    z_index: int = IntField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:
            >>> per_section_parameters = PerSectionParameters.find(client, query_filters=[PerSectionParameters.run.name == "TS_026"])

            Get all results for this type:

            >>> per_section_parameters = PerSectionParameters.find(client)
        """
        return super(PerSectionParameters, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an PerSectionParameters by ID:

            >>> per_section_parameters = PerSectionParameters.get_by_id(client, 1)
            >>> print(per_section_parameters.id)
        """
        return super(PerSectionParameters, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )


class Run(Model):
    """None

    Attributes:
        id (int): Numeric identifier (May change!)
        alignments (List[Alignment]): The alignments of this run
        annotations (List[Annotation]): The annotations of this run
        dataset (Dataset): The dataset this run is a part of
        dataset_id (int): None
        frames (List[Frame]): The frames of this run
        gain_files (List[GainFile]): The gain files of this run
        frame_acquisition_files (List[FrameAcquisitionFile]): The frame acquisition files of this run
        per_section_parameters (List[PerSectionParameters]): The per section parameters of this run
        tiltseries (List[TiltSeries]): The tilt series of this run
        tomogram_voxel_spacings (List[TomogramVoxelSpacing]): The tomogram voxel spacings of this run
        tomograms (List[Tomogram]): The tomograms of this run
        name (str): Short name for this experiment run
        s3_prefix (str): The S3 public bucket path where this run is contained
        https_prefix (str): The HTTPS directory path where this run is contained url
    """

    _gql_type: str = "Run"
    _gql_root_field: str = "runs"

    id: int = IntField()
    alignments: List[Alignment] = ListRelationship("Alignment", "id", "run_id")
    annotations: List[Annotation] = ListRelationship("Annotation", "id", "run_id")
    dataset: Dataset = ItemRelationship("Dataset", "dataset_id", "id")
    dataset_id: int = IntField()
    frames: List[Frame] = ListRelationship("Frame", "id", "run_id")
    gain_files: List[GainFile] = ListRelationship("GainFile", "id", "run_id")
    frame_acquisition_files: List[FrameAcquisitionFile] = ListRelationship(
        "FrameAcquisitionFile",
        "id",
        "run_id",
    )
    per_section_parameters: List[PerSectionParameters] = ListRelationship(
        "PerSectionParameters",
        "id",
        "run_id",
    )
    tiltseries: List[TiltSeries] = ListRelationship("TiltSeries", "id", "run_id")
    tomogram_voxel_spacings: List[TomogramVoxelSpacing] = ListRelationship(
        "TomogramVoxelSpacing",
        "id",
        "run_id",
    )
    tomograms: List[Tomogram] = ListRelationship("Tomogram", "id", "run_id")
    name: str = StringField()
    s3_prefix: str = StringField()
    https_prefix: str = StringField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:
            Filter runs by attributes, including attributes in related models:

            >>> runs = Run.find(client, query_filters=[Run.name == "TS_026", Run.dataset.id == 10000])
            >>> runs = Run.find(client, query_filters=[Run.name._in(['TS_026', 'TS_027']), Run.annotations.object_name.ilike('%membrane%')])

            Get all results for this type:

            >>> runs = Run.find(client)
        """
        return super(Run, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an Run by ID:

            >>> run = Run.get_by_id(client, 1)
            >>> print(run.name)
        """
        return super(Run, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )

    def download_everything(self, dest_path: Optional[str] = None):
        """Download all of the data for this run.

        Args:
            dest_path (Optional[str], optional): Choose a destination directory. Defaults to $CWD.
        """
        download_directory(self.s3_prefix, self.dataset.s3_prefix, dest_path)

    def download_frames(self, dest_path: Optional[str] = None):
        download_directory(
            os.path.join(self.s3_prefix, "Frames"),
            self.s3_prefix,
            dest_path,
        )


class TiltSeries(Model):
    """None

    Attributes:
        id (int): Numeric identifier (May change!)
        alignments (List[Alignment]): The alignments of this tilt series
        run (Run): The run this tilt series is a part of
        run_id (int): None
        deposition (Deposition): The deposition this tilt series is a part of
        deposition_id (int): None
        s3_omezarr_dir (str): S3 path to this tiltseries in multiscale OME-Zarr format
        file_size_omezarr (float): Size of the tiltseries in OME-Zarr format in bytes
        s3_mrc_file (str): S3 path to this tiltseries in MRC format (no scaling)
        file_size_mrc (float): Size of the tiltseries in MRC format in bytes
        https_omezarr_dir (str): HTTPS path to this tiltseries in multiscale OME-Zarr format
        https_mrc_file (str): HTTPS path to this tiltseries in MRC format (no scaling)
        s3_angle_list (str): S3 path to the angle list file for this tiltseries
        https_angle_list (str): HTTPS path to the angle list file for this tiltseries
        acceleration_voltage (int): Electron Microscope Accelerator voltage in volts
        spherical_aberration_constant (float): Spherical Aberration Constant of the objective lens in millimeters
        microscope_manufacturer (str): Name of the microscope manufacturer (FEI, TFS, JEOL)
        microscope_model (str): Microscope model name
        microscope_energy_filter (str): Energy filter setup used
        microscope_phase_plate (str): Phase plate configuration
        microscope_image_corrector (str): Image corrector setup
        microscope_additional_info (str): Other microscope optical setup information, in addition to energy filter, phase plate and image corrector
        per_section_parameters (List[PerSectionParameters]): The per section parameters of this tilt series
        camera_manufacturer (str): Name of the camera manufacturer
        camera_model (str): Camera model name
        tilt_min (float): Minimal tilt angle in degrees
        tilt_max (float): Maximal tilt angle in degrees
        tilt_range (float): Total tilt range in degrees
        tilt_step (float): Tilt step in degrees
        tilting_scheme (str): The order of stage tilting during acquisition of the data
        tilt_axis (float): Rotation angle in degrees
        total_flux (float): Number of Electrons reaching the specimen in a square Angstrom area for the entire tilt series
        data_acquisition_software (str): Software used to collect data
        related_empiar_entry (str): If a tilt series is deposited into EMPIAR, enter the EMPIAR dataset identifier
        binning_from_frames (float): Describes the binning factor from frames to tilt series file
        tilt_series_quality (int): Author assessment of tilt series quality within the dataset (1-5, 5 is best)
        is_aligned (bool): Whether this tilt series is aligned
        pixel_spacing (float): Pixel spacing equal in both axes in angstroms
        aligned_tiltseries_binning (int): Binning factor of the aligned tilt series
        size_x (int): Number of pixels in the 3D data fast axis
        size_y (int): Number of pixels in the 3D data medium axis
        size_z (int): Number of pixels in the 3D data slow axis
    """

    _gql_type: str = "Tiltseries"
    _gql_root_field: str = "tiltseries"

    id: int = IntField()
    alignments: List[Alignment] = ListRelationship("Alignment", "id", "tiltseries_id")
    run: Run = ItemRelationship("Run", "run_id", "id")
    run_id: int = IntField()
    deposition: Deposition = ItemRelationship("Deposition", "deposition_id", "id")
    deposition_id: int = IntField()
    s3_omezarr_dir: str = StringField()
    file_size_omezarr: float = FloatField()
    s3_mrc_file: str = StringField()
    file_size_mrc: float = FloatField()
    https_omezarr_dir: str = StringField()
    https_mrc_file: str = StringField()
    s3_angle_list: str = StringField()
    https_angle_list: str = StringField()
    acceleration_voltage: int = IntField()
    spherical_aberration_constant: float = FloatField()
    microscope_manufacturer: str = StringField()
    microscope_model: str = StringField()
    microscope_energy_filter: str = StringField()
    microscope_phase_plate: str = StringField()
    microscope_image_corrector: str = StringField()
    microscope_additional_info: str = StringField()
    per_section_parameters: List[PerSectionParameters] = ListRelationship(
        "PerSectionParameters",
        "id",
        "tiltseries_id",
    )
    camera_manufacturer: str = StringField()
    camera_model: str = StringField()
    tilt_min: float = FloatField()
    tilt_max: float = FloatField()
    tilt_range: float = FloatField()
    tilt_step: float = FloatField()
    tilting_scheme: str = StringField()
    tilt_axis: float = FloatField()
    total_flux: float = FloatField()
    data_acquisition_software: str = StringField()
    related_empiar_entry: str = StringField()
    binning_from_frames: float = FloatField()
    tilt_series_quality: int = IntField()
    is_aligned: bool = BooleanField()
    pixel_spacing: float = FloatField()
    aligned_tiltseries_binning: int = IntField()
    size_x: int = IntField()
    size_y: int = IntField()
    size_z: int = IntField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:
            >>> tilt_series = TiltSeries.find(client, query_filters=[TiltSeries.run.name == "TS_026"])

            Get all results for this type:

            >>> tilt_series = TiltSeries.find(client)
        """
        return super(TiltSeries, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an TiltSeries by ID:

            >>> tilt_series = TiltSeries.get_by_id(client, 1)
            >>> print(tilt_series.id)
        """
        return super(TiltSeries, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )

    def download_angle_list(self, dest_path: Optional[str] = None):
        """Download the angle list for this tiltseries

        Args:
            dest_path (Optional[str], optional): Choose a destination directory. Defaults to $CWD.
        """
        download_https(self.https_angle_list, dest_path)

    def download_alignment_file(self, dest_path: Optional[str] = None):
        """Download the alignment file for this tiltseries

        Args:
            dest_path (Optional[str], optional): Choose a destination directory. Defaults to $CWD.
        """
        download_https(self.https_alignment_file, dest_path)

    def download_omezarr(self, dest_path: Optional[str] = None):
        """Download the omezarr version of this tiltseries

        Args:
            dest_path (Optional[str], optional): Choose a destination directory. Defaults to $CWD.
        """
        recursive_prefix = "/".join(self.s3_omezarr_dir.split("/")[:-1]) + "/"
        download_directory(self.s3_omezarr_dir, recursive_prefix, dest_path)

    def download_mrcfile(
        self,
        dest_path: Optional[str] = None,
    ):
        """Download an MRC file for this tiltseries

        Args:
            dest_path (Optional[str], optional): Choose a destination directory. Defaults to $CWD.
        """
        url = self.https_mrc_file
        download_https(url, dest_path)


class Tomogram(Model):
    """Metadata describing a tomogram.

    Attributes:
        id (int): Numeric identifier (May change!)
        alignment (Alignment): The alignment this tomogram is a part of
        alignment_id (int): None
        authors (List[TomogramAuthor]): The tomogram authors of this tomogram
        deposition (Deposition): The deposition this tomogram is a part of
        deposition_id (int): None
        run (Run): The run this tomogram is a part of
        run_id (int): None
        tomogram_voxel_spacing (TomogramVoxelSpacing): The tomogram voxel spacing this tomogram is a part of
        tomogram_voxel_spacing_id (int): None
        name (str): Short name for this tomogram
        size_x (int): Number of pixels in the 3D data fast axis
        size_y (int): Number of pixels in the 3D data medium axis
        size_z (int): Number of pixels in the 3D data slow axis.  This is the image projection direction at zero stage tilt
        voxel_spacing (float): Voxel spacing equal in all three axes in angstroms
        fiducial_alignment_status (str): Fiducial Alignment status: True = aligned with fiducial False = aligned without fiducial
        reconstruction_method (str): Describe reconstruction method (WBP, SART, SIRT)
        processing (str): Describe additional processing used to derive the tomogram
        tomogram_version (float): Version of tomogram
        processing_software (str): Processing software used to derive the tomogram
        reconstruction_software (str): Name of software used for reconstruction
        is_portal_standard (bool): whether this tomogram adheres to portal standards
        is_author_submitted (bool): Whether this tomogram was submitted by the author of the dataset it belongs to.
        is_visualization_default (bool): Data curator’s subjective choice of default tomogram to display in visualization for a run
        s3_omezarr_dir (str): S3 path to this tomogram in multiscale OME-Zarr format
        https_omezarr_dir (str): HTTPS path to this tomogram in multiscale OME-Zarr format
        file_size_omezarr (float): Size of the tomogram in OME-Zarr format in bytes
        s3_mrc_file (str): S3 path to this tomogram in MRC format (no scaling)
        https_mrc_file (str): HTTPS path to this tomogram in MRC format (no scaling)
        file_size_mrc (float): Size of the tomogram in MRC format in bytes
        scale_0_dimensions (str): comma separated x,y,z dimensions of the unscaled tomogram
        scale_1_dimensions (str): comma separated x,y,z dimensions of the scale1 tomogram
        scale_2_dimensions (str): comma separated x,y,z dimensions of the scale2 tomogram
        ctf_corrected (bool): Whether this tomogram is CTF corrected
        offset_x (int): x offset data relative to the canonical tomogram in pixels
        offset_y (int): y offset data relative to the canonical tomogram in pixels
        offset_z (int): z offset data relative to the canonical tomogram in pixels
        key_photo_url (str): URL for the key photo
        key_photo_thumbnail_url (str): URL for the thumbnail of key photo
        neuroglancer_config (str): the compact json of neuroglancer config
        publications (str): Comma-separated list of DOIs for publications associated with the tomogram.
        related_database_entries (str): If a CryoET tomogram is also deposited into another database, enter the database identifier here (e.g. EMPIAR-11445). Use a comma to separate multiple identifiers.
        deposition_date (date): The date a data item was received by the cryoET data portal.
        release_date (date): The date a data item was received by the cryoET data portal.
        last_modified_date (date): The date a piece of data was last modified on the cryoET data portal.
    """

    _gql_type: str = "Tomogram"
    _gql_root_field: str = "tomograms"

    id: int = IntField()
    alignment: Alignment = ItemRelationship("Alignment", "alignment_id", "id")
    alignment_id: int = IntField()
    authors: List[TomogramAuthor] = ListRelationship(
        "TomogramAuthor",
        "id",
        "tomogram_id",
    )
    deposition: Deposition = ItemRelationship("Deposition", "deposition_id", "id")
    deposition_id: int = IntField()
    run: Run = ItemRelationship("Run", "run_id", "id")
    run_id: int = IntField()
    tomogram_voxel_spacing: TomogramVoxelSpacing = ItemRelationship(
        "TomogramVoxelSpacing",
        "tomogram_voxel_spacing_id",
        "id",
    )
    tomogram_voxel_spacing_id: int = IntField()
    name: str = StringField()
    size_x: int = IntField()
    size_y: int = IntField()
    size_z: int = IntField()
    voxel_spacing: float = FloatField()
    fiducial_alignment_status: str = StringField()
    reconstruction_method: str = StringField()
    processing: str = StringField()
    tomogram_version: float = FloatField()
    processing_software: str = StringField()
    reconstruction_software: str = StringField()
    is_portal_standard: bool = BooleanField()
    is_author_submitted: bool = BooleanField()
    is_visualization_default: bool = BooleanField()
    s3_omezarr_dir: str = StringField()
    https_omezarr_dir: str = StringField()
    file_size_omezarr: float = FloatField()
    s3_mrc_file: str = StringField()
    https_mrc_file: str = StringField()
    file_size_mrc: float = FloatField()
    scale_0_dimensions: str = StringField()
    scale_1_dimensions: str = StringField()
    scale_2_dimensions: str = StringField()
    ctf_corrected: bool = BooleanField()
    offset_x: int = IntField()
    offset_y: int = IntField()
    offset_z: int = IntField()
    key_photo_url: str = StringField()
    key_photo_thumbnail_url: str = StringField()
    neuroglancer_config: str = StringField()
    publications: str = StringField()
    related_database_entries: str = StringField()
    deposition_date: date = DateField()
    release_date: date = DateField()
    last_modified_date: date = DateField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:
            >>> tomograms = Tomogram.find(client, query_filters=[Tomogram.run.name == "TS_026"])

            Get all results for this type:

            >>> tomograms = Tomogram.find(client)
        """
        return super(Tomogram, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an Tomogram by ID:

            >>> tomogram = Tomogram.get_by_id(client, 1)
            >>> print(tomogram.name)
        """
        return super(Tomogram, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )

    def download_omezarr(self, dest_path: Optional[str] = None):
        """Download the OME-Zarr version of this tomogram

        Args:
            dest_path (Optional[str], optional): Choose a destination directory. Defaults to $CWD.
        """
        recursive_prefix = "/".join(self.s3_omezarr_dir.split("/")[:-1]) + "/"
        download_directory(self.s3_omezarr_dir, recursive_prefix, dest_path)

    def download_mrcfile(self, dest_path: Optional[str] = None):
        """Download an MRC file of this tomogram

        Args:
            dest_path (Optional[str], optional): Choose a destination directory. Defaults to $CWD.
        """
        url = self.https_mrc_file
        download_https(url, dest_path)

    def download_all_annotations(
        self,
        dest_path: Optional[str] = None,
        format: Optional[str] = None,
        shape: Optional[str] = None,
    ):
        """Download all annotation files for this tomogram

        Args:
            dest_path (Optional[str], optional): Choose a destination directory. Defaults to $CWD.
            shape (Optional[str], optional): Choose a specific shape type to download (e.g.: OrientedPoint, SegmentationMask)
            format (Optional[str], optional): Choose a specific file format to download (e.g.: mrc, ndjson)
        """
        filters = [
            AnnotationFile.tomogram_voxel_spacing_id == self.tomogram_voxel_spacing_id,
            AnnotationFile.alignment_id == self.alignment_id,
        ]
        if shape:
            filters.append(AnnotationFile.annotation_shape.shape_type == shape)
        if format:
            filters.append(AnnotationFile.format == format)
        anno_files = AnnotationFile.find(self._client, filters)
        downloaded_metadata = set()
        for file in anno_files:
            file.download(dest_path)
            annotation_id = file.annotation_shape.annotation_id
            if annotation_id not in downloaded_metadata:
                downloaded_metadata.add(annotation_id)
                file.annotation_shape.annotation.download_metadata(dest_path)


class TomogramAuthor(Model):
    """Author of a tomogram

    Attributes:
        id (int): Numeric identifier (May change!)
        tomogram (Tomogram): The tomogram this tomogram author is a part of
        tomogram_id (int): None
        author_list_order (int): The order in which the author appears in the publication
        orcid (str): A unique, persistent identifier for researchers, provided by ORCID.
        kaggle_id (str): A unique, persistent identifier for kaggle users at kaggle.com.
        name (str): Full name of an author (e.g. Jane Doe).
        email (str): Email address for this author
        affiliation_name (str): Name of the institutions an author is affiliated with. Comma separated
        affiliation_address (str): Address of the institution an author is affiliated with.
        affiliation_identifier (str): A unique identifier assigned to the affiliated institution by The Research Organization Registry (ROR).
        corresponding_author_status (bool): Indicates whether an author is the corresponding author
        primary_author_status (bool): Indicates whether an author is the main person creating the tomogram
    """

    _gql_type: str = "TomogramAuthor"
    _gql_root_field: str = "tomogramAuthors"

    id: int = IntField()
    tomogram: Tomogram = ItemRelationship("Tomogram", "tomogram_id", "id")
    tomogram_id: int = IntField()
    author_list_order: int = IntField()
    orcid: str = StringField()
    kaggle_id: str = StringField()
    name: str = StringField()
    email: str = StringField()
    affiliation_name: str = StringField()
    affiliation_address: str = StringField()
    affiliation_identifier: str = StringField()
    corresponding_author_status: bool = BooleanField()
    primary_author_status: bool = BooleanField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:

            Get all results for this type:

            >>> tomogram_authors = TomogramAuthor.find(client)
        """
        return super(TomogramAuthor, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an TomogramAuthor by ID:

            >>> tomogram_author = TomogramAuthor.get_by_id(client, 1)
            >>> print(tomogram_author.name)
        """
        return super(TomogramAuthor, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )


class TomogramVoxelSpacing(Model):
    """Voxel spacings for a run

    Attributes:
        id (int): Numeric identifier (May change!)
        annotation_files (List[AnnotationFile]): The annotation files of this tomogram voxel spacing
        run (Run): The run this tomogram voxel spacing is a part of
        run_id (int): None
        tomograms (List[Tomogram]): The tomograms of this tomogram voxel spacing
        voxel_spacing (float): The voxel spacing for the tomograms in this set in angstroms
        s3_prefix (str): The S3 public bucket path where this tomogram voxel spacing is contained
        https_prefix (str): The HTTPS directory path where this tomogram voxel spacing is contained
    """

    _gql_type: str = "TomogramVoxelSpacing"
    _gql_root_field: str = "tomogramVoxelSpacings"

    id: int = IntField()
    annotation_files: List[AnnotationFile] = ListRelationship(
        "AnnotationFile",
        "id",
        "tomogram_voxel_spacing_id",
    )
    run: Run = ItemRelationship("Run", "run_id", "id")
    run_id: int = IntField()
    tomograms: List[Tomogram] = ListRelationship(
        "Tomogram",
        "id",
        "tomogram_voxel_spacing_id",
    )
    voxel_spacing: float = FloatField()
    s3_prefix: str = StringField()
    https_prefix: str = StringField()

    @classmethod
    def find(
        cls,
        client: Client,
        query_filters: Optional[Iterable[GQLExpression]] = None,
    ):
        """
        Examples:
            >>> tomogram_voxel_spacings = TomogramVoxelSpacing.find(client, query_filters=[TomogramVoxelSpacing.run.name == "TS_026"])

            Get all results for this type:

            >>> tomogram_voxel_spacings = TomogramVoxelSpacing.find(client)
        """
        return super(TomogramVoxelSpacing, cls).find(client, query_filters)

    find.__func__.__doc__ = Model.find.__func__.__doc__ + find.__func__.__doc__

    @classmethod
    def get_by_id(cls, client: Client, id: int):
        """
        Examples:
            Get an TomogramVoxelSpacing by ID:

            >>> tomogram_voxel_spacing = TomogramVoxelSpacing.get_by_id(client, 1)
            >>> print(tomogram_voxel_spacing.id)
        """
        return super(TomogramVoxelSpacing, cls).get_by_id(client, id)

    get_by_id.__func__.__doc__ = (
        Model.get_by_id.__func__.__doc__ + get_by_id.__func__.__doc__
    )

    def download_everything(self, dest_path: Optional[str] = None):
        """Download all of the data for this tomogram voxel spacing.

        Args:
            dest_path (Optional[str], optional): Choose a destination directory. Defaults to $CWD.
        """
        download_directory(self.s3_prefix, self.run.s3_prefix, dest_path)


Alignment.setup()
Annotation.setup()
AnnotationAuthor.setup()
AnnotationFile.setup()
AnnotationMethodLink.setup()
AnnotationShape.setup()
Dataset.setup()
DatasetAuthor.setup()
DatasetFunding.setup()
Deposition.setup()
DepositionAuthor.setup()
DepositionType.setup()
Frame.setup()
FrameAcquisitionFile.setup()
GainFile.setup()
PerSectionAlignmentParameters.setup()
PerSectionParameters.setup()
Run.setup()
TiltSeries.setup()
Tomogram.setup()
TomogramAuthor.setup()
TomogramVoxelSpacing.setup()
