type Query {
  gainFiles(where: GainFileWhereClause = null, orderBy: [GainFileOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [GainFile!]!
  frameAcquisitionFiles(where: FrameAcquisitionFileWhereClause = null, orderBy: [FrameAcquisitionFileOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [FrameAcquisitionFile!]!
  alignments(where: AlignmentWhereClause = null, orderBy: [AlignmentOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [Alignment!]!
  annotationAuthors(where: AnnotationAuthorWhereClause = null, orderBy: [AnnotationAuthorOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [AnnotationAuthor!]!
  annotationFiles(where: AnnotationFileWhereClause = null, orderBy: [AnnotationFileOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [AnnotationFile!]!
  annotationShapes(where: AnnotationShapeWhereClause = null, orderBy: [AnnotationShapeOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [AnnotationShape!]!
  annotations(where: AnnotationWhereClause = null, orderBy: [AnnotationOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [Annotation!]!
  datasetAuthors(where: DatasetAuthorWhereClause = null, orderBy: [DatasetAuthorOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [DatasetAuthor!]!
  datasetFunding(where: DatasetFundingWhereClause = null, orderBy: [DatasetFundingOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [DatasetFunding!]!
  datasets(where: DatasetWhereClause = null, orderBy: [DatasetOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [Dataset!]!
  depositionAuthors(where: DepositionAuthorWhereClause = null, orderBy: [DepositionAuthorOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [DepositionAuthor!]!
  depositions(where: DepositionWhereClause = null, orderBy: [DepositionOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [Deposition!]!
  depositionTypes(where: DepositionTypeWhereClause = null, orderBy: [DepositionTypeOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [DepositionType!]!
  frames(where: FrameWhereClause = null, orderBy: [FrameOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [Frame!]!
  perSectionAlignmentParameters(where: PerSectionAlignmentParametersWhereClause = null, orderBy: [PerSectionAlignmentParametersOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [PerSectionAlignmentParameters!]!
  runs(where: RunWhereClause = null, orderBy: [RunOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [Run!]!
  tiltseries(where: TiltseriesWhereClause = null, orderBy: [TiltseriesOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [Tiltseries!]!
  tomogramAuthors(where: TomogramAuthorWhereClause = null, orderBy: [TomogramAuthorOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [TomogramAuthor!]!
  tomogramVoxelSpacings(where: TomogramVoxelSpacingWhereClause = null, orderBy: [TomogramVoxelSpacingOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [TomogramVoxelSpacing!]!
  tomograms(where: TomogramWhereClause = null, orderBy: [TomogramOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [Tomogram!]!
  annotationMethodLinks(where: AnnotationMethodLinkWhereClause = null, orderBy: [AnnotationMethodLinkOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [AnnotationMethodLink!]!
  gainFilesAggregate(where: GainFileWhereClause = null): GainFileAggregate!
  frameAcquisitionFilesAggregate(where: FrameAcquisitionFileWhereClause = null): FrameAcquisitionFileAggregate!
  alignmentsAggregate(where: AlignmentWhereClause = null): AlignmentAggregate!
  annotationAuthorsAggregate(where: AnnotationAuthorWhereClause = null): AnnotationAuthorAggregate!
  annotationFilesAggregate(where: AnnotationFileWhereClause = null): AnnotationFileAggregate!
  annotationShapesAggregate(where: AnnotationShapeWhereClause = null): AnnotationShapeAggregate!
  annotationsAggregate(where: AnnotationWhereClause = null): AnnotationAggregate!
  datasetAuthorsAggregate(where: DatasetAuthorWhereClause = null): DatasetAuthorAggregate!
  datasetFundingAggregate(where: DatasetFundingWhereClause = null): DatasetFundingAggregate!
  datasetsAggregate(where: DatasetWhereClause = null): DatasetAggregate!
  depositionAuthorsAggregate(where: DepositionAuthorWhereClause = null): DepositionAuthorAggregate!
  depositionsAggregate(where: DepositionWhereClause = null): DepositionAggregate!
  depositionTypesAggregate(where: DepositionTypeWhereClause = null): DepositionTypeAggregate!
  framesAggregate(where: FrameWhereClause = null): FrameAggregate!
  perSectionAlignmentParametersAggregate(where: PerSectionAlignmentParametersWhereClause = null): PerSectionAlignmentParametersAggregate!
  runsAggregate(where: RunWhereClause = null): RunAggregate!
  tiltseriesAggregate(where: TiltseriesWhereClause = null): TiltseriesAggregate!
  tomogramAuthorsAggregate(where: TomogramAuthorWhereClause = null): TomogramAuthorAggregate!
  tomogramVoxelSpacingsAggregate(where: TomogramVoxelSpacingWhereClause = null): TomogramVoxelSpacingAggregate!
  tomogramsAggregate(where: TomogramWhereClause = null): TomogramAggregate!
  annotationMethodLinksAggregate(where: AnnotationMethodLinkWhereClause = null): AnnotationMethodLinkAggregate!
}

"""Gain values for frames in this run"""
type GainFile implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """Numeric identifier (May change!)"""
  id: Int!
  run(where: RunWhereClause = null, orderBy: [RunOrderByClause!] = []): Run
  runId: Int!

  """Path to the file in s3"""
  s3FilePath: String!

  """Path to the file as an https url"""
  httpsFilePath: String!
}

interface EntityInterface implements Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
}

"""An object with a Globally Unique ID"""
interface Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
}

"""
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
"""
scalar GlobalID

type Run implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """Numeric identifier (May change!)"""
  id: Int!
  alignments(
    where: AlignmentWhereClause = null
    orderBy: [AlignmentOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AlignmentConnection!
  alignmentsAggregate(where: AlignmentWhereClause = null): AlignmentAggregate
  annotations(
    where: AnnotationWhereClause = null
    orderBy: [AnnotationOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AnnotationConnection!
  annotationsAggregate(where: AnnotationWhereClause = null): AnnotationAggregate
  dataset(where: DatasetWhereClause = null, orderBy: [DatasetOrderByClause!] = []): Dataset
  datasetId: Int!
  frames(
    where: FrameWhereClause = null
    orderBy: [FrameOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): FrameConnection!
  framesAggregate(where: FrameWhereClause = null): FrameAggregate
  gainFiles(
    where: GainFileWhereClause = null
    orderBy: [GainFileOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): GainFileConnection!
  gainFilesAggregate(where: GainFileWhereClause = null): GainFileAggregate
  frameAcquisitionFiles(
    where: FrameAcquisitionFileWhereClause = null
    orderBy: [FrameAcquisitionFileOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): FrameAcquisitionFileConnection!
  frameAcquisitionFilesAggregate(where: FrameAcquisitionFileWhereClause = null): FrameAcquisitionFileAggregate
  tiltseries(
    where: TiltseriesWhereClause = null
    orderBy: [TiltseriesOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): TiltseriesConnection!
  tiltseriesAggregate(where: TiltseriesWhereClause = null): TiltseriesAggregate
  tomogramVoxelSpacings(
    where: TomogramVoxelSpacingWhereClause = null
    orderBy: [TomogramVoxelSpacingOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): TomogramVoxelSpacingConnection!
  tomogramVoxelSpacingsAggregate(where: TomogramVoxelSpacingWhereClause = null): TomogramVoxelSpacingAggregate
  tomograms(
    where: TomogramWhereClause = null
    orderBy: [TomogramOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): TomogramConnection!
  tomogramsAggregate(where: TomogramWhereClause = null): TomogramAggregate

  """Short name for this experiment run"""
  name: String!

  """The S3 public bucket path where this run is contained"""
  s3Prefix: String!

  """The HTTPS directory path where this run is contained url"""
  httpsPrefix: String!
}

"""A connection to a list of items."""
type AlignmentConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [AlignmentEdge!]!
}

"""Information to aid in pagination."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""An edge in a connection."""
type AlignmentEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Alignment!
}

"""Tiltseries Alignment"""
type Alignment implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """Numeric identifier (May change!)"""
  id: Int!
  annotationFiles(
    where: AnnotationFileWhereClause = null
    orderBy: [AnnotationFileOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AnnotationFileConnection!
  annotationFilesAggregate(where: AnnotationFileWhereClause = null): AnnotationFileAggregate
  perSectionAlignments(
    where: PerSectionAlignmentParametersWhereClause = null
    orderBy: [PerSectionAlignmentParametersOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): PerSectionAlignmentParametersConnection!
  perSectionAlignmentsAggregate(where: PerSectionAlignmentParametersWhereClause = null): PerSectionAlignmentParametersAggregate
  deposition(where: DepositionWhereClause = null, orderBy: [DepositionOrderByClause!] = []): Deposition
  depositionId: Int
  tiltseries(where: TiltseriesWhereClause = null, orderBy: [TiltseriesOrderByClause!] = []): Tiltseries
  tiltseriesId: Int
  tomograms(
    where: TomogramWhereClause = null
    orderBy: [TomogramOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): TomogramConnection!
  tomogramsAggregate(where: TomogramWhereClause = null): TomogramAggregate
  run(where: RunWhereClause = null, orderBy: [RunOrderByClause!] = []): Run
  runId: Int

  """Whether this a LOCAL or GLOBAL alignment"""
  alignmentType: alignment_type_enum

  """The method used to create this alignment"""
  alignmentMethod: alignment_method_type_enum

  """X dimension of the reconstruction volume in angstrom"""
  volumeXDimension: Float

  """Y dimension of the reconstruction volume in angstrom"""
  volumeYDimension: Float

  """Z dimension of the reconstruction volume in angstrom"""
  volumeZDimension: Float

  """X shift of the reconstruction volume in angstrom"""
  volumeXOffset: Float

  """Y shift of the reconstruction volume in angstrom"""
  volumeYOffset: Float

  """Z shift of the reconstruction volume in angstrom"""
  volumeZOffset: Float

  """Additional X rotation of the reconstruction volume in degrees"""
  xRotationOffset: Float

  """Additional tilt offset in degrees"""
  tiltOffset: Float

  """A placeholder for the affine transformation matrix."""
  affineTransformationMatrix: String

  """S3 path to the metadata file for this alignment"""
  s3AlignmentMetadata: String

  """HTTPS url to the metadata file for this alignment"""
  httpsAlignmentMetadata: String

  """Whether this is the portal standard alignment"""
  isPortalStandard: Boolean
}

"""A connection to a list of items."""
type AnnotationFileConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [AnnotationFileEdge!]!
}

"""An edge in a connection."""
type AnnotationFileEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: AnnotationFile!
}

"""Metadata for files associated with an annotation"""
type AnnotationFile implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """Numeric identifier (May change!)"""
  id: Int!
  alignment(where: AlignmentWhereClause = null, orderBy: [AlignmentOrderByClause!] = []): Alignment
  alignmentId: Int
  annotationShape(where: AnnotationShapeWhereClause = null, orderBy: [AnnotationShapeOrderByClause!] = []): AnnotationShape
  annotationShapeId: Int
  tomogramVoxelSpacing(where: TomogramVoxelSpacingWhereClause = null, orderBy: [TomogramVoxelSpacingOrderByClause!] = []): TomogramVoxelSpacing
  tomogramVoxelSpacingId: Int

  """File format for this file"""
  format: String!

  """s3 path of the annotation file"""
  s3Path: String!

  """HTTPS path for this annotation file"""
  httpsPath: String!

  """
  Data curator’s subjective choice of default annotation to display in visualization for an object
  """
  isVisualizationDefault: Boolean

  """
  The source type for the annotation file (dataset_author, community, or portal_standard)
  """
  source: annotation_file_source_enum
}

input AlignmentWhereClause {
  annotationFiles: AnnotationFileWhereClause
  perSectionAlignments: PerSectionAlignmentParametersWhereClause
  deposition: DepositionWhereClause
  depositionId: IntComparators
  tiltseries: TiltseriesWhereClause
  tiltseriesId: IntComparators
  tomograms: TomogramWhereClause
  run: RunWhereClause
  runId: IntComparators
  alignmentType: Alignment_type_enumEnumComparators
  alignmentMethod: Alignment_method_type_enumEnumComparators
  volumeXDimension: FloatComparators
  volumeYDimension: FloatComparators
  volumeZDimension: FloatComparators
  volumeXOffset: FloatComparators
  volumeYOffset: FloatComparators
  volumeZOffset: FloatComparators
  xRotationOffset: FloatComparators
  tiltOffset: FloatComparators
  affineTransformationMatrix: StrComparators
  s3AlignmentMetadata: StrComparators
  httpsAlignmentMetadata: StrComparators
  isPortalStandard: BoolComparators
  id: IntComparators
}

input AnnotationFileWhereClause {
  alignment: AlignmentWhereClause
  alignmentId: IntComparators
  annotationShape: AnnotationShapeWhereClause
  annotationShapeId: IntComparators
  tomogramVoxelSpacing: TomogramVoxelSpacingWhereClause
  tomogramVoxelSpacingId: IntComparators
  format: StrComparators
  s3Path: StrComparators
  httpsPath: StrComparators
  isVisualizationDefault: BoolComparators
  source: Annotation_file_source_enumEnumComparators
  id: IntComparators
}

input IntComparators {
  _eq: Int
  _neq: Int
  _in: [Int!]
  _nin: [Int!]
  _gt: Int
  _gte: Int
  _lt: Int
  _lte: Int
  _is_null: Boolean
}

input AnnotationShapeWhereClause {
  annotation: AnnotationWhereClause
  annotationId: IntComparators
  annotationFiles: AnnotationFileWhereClause
  shapeType: Annotation_file_shape_type_enumEnumComparators
  id: IntComparators
}

input AnnotationWhereClause {
  run: RunWhereClause
  runId: IntComparators
  annotationShapes: AnnotationShapeWhereClause
  methodLinks: AnnotationMethodLinkWhereClause
  authors: AnnotationAuthorWhereClause
  deposition: DepositionWhereClause
  depositionId: IntComparators
  s3MetadataPath: StrComparators
  httpsMetadataPath: StrComparators
  annotationPublication: StrComparators
  annotationMethod: StrComparators
  groundTruthStatus: BoolComparators
  objectId: StrComparators
  objectName: StrComparators
  objectDescription: StrComparators
  objectState: StrComparators
  objectCount: IntComparators
  confidencePrecision: FloatComparators
  confidenceRecall: FloatComparators
  groundTruthUsed: StrComparators
  annotationSoftware: StrComparators
  isCuratorRecommended: BoolComparators
  methodType: Annotation_method_type_enumEnumComparators
  depositionDate: DatetimeComparators
  releaseDate: DatetimeComparators
  lastModifiedDate: DatetimeComparators
  id: IntComparators
}

input RunWhereClause {
  alignments: AlignmentWhereClause
  annotations: AnnotationWhereClause
  dataset: DatasetWhereClause
  datasetId: IntComparators
  frames: FrameWhereClause
  gainFiles: GainFileWhereClause
  frameAcquisitionFiles: FrameAcquisitionFileWhereClause
  tiltseries: TiltseriesWhereClause
  tomogramVoxelSpacings: TomogramVoxelSpacingWhereClause
  tomograms: TomogramWhereClause
  name: StrComparators
  s3Prefix: StrComparators
  httpsPrefix: StrComparators
  id: IntComparators
}

input DatasetWhereClause {
  deposition: DepositionWhereClause
  depositionId: IntComparators
  fundingSources: DatasetFundingWhereClause
  authors: DatasetAuthorWhereClause
  runs: RunWhereClause
  title: StrComparators
  description: StrComparators
  organismName: StrComparators
  organismTaxid: IntComparators
  tissueName: StrComparators
  tissueId: StrComparators
  cellName: StrComparators
  cellTypeId: StrComparators
  cellStrainName: StrComparators
  cellStrainId: StrComparators
  sampleType: Sample_type_enumEnumComparators
  samplePreparation: StrComparators
  gridPreparation: StrComparators
  otherSetup: StrComparators
  keyPhotoUrl: StrComparators
  keyPhotoThumbnailUrl: StrComparators
  cellComponentName: StrComparators
  cellComponentId: StrComparators
  depositionDate: DatetimeComparators
  releaseDate: DatetimeComparators
  lastModifiedDate: DatetimeComparators
  datasetPublications: StrComparators
  relatedDatabaseEntries: StrComparators
  s3Prefix: StrComparators
  httpsPrefix: StrComparators
  id: IntComparators
}

input DepositionWhereClause {
  authors: DepositionAuthorWhereClause
  alignments: AlignmentWhereClause
  annotations: AnnotationWhereClause
  datasets: DatasetWhereClause
  frames: FrameWhereClause
  tiltseries: TiltseriesWhereClause
  tomograms: TomogramWhereClause
  title: StrComparators
  description: StrComparators
  depositionTypes: DepositionTypeWhereClause
  depositionPublications: StrComparators
  relatedDatabaseEntries: StrComparators
  depositionDate: DatetimeComparators
  releaseDate: DatetimeComparators
  lastModifiedDate: DatetimeComparators
  keyPhotoUrl: StrComparators
  keyPhotoThumbnailUrl: StrComparators
  id: IntComparators
}

input DepositionAuthorWhereClause {
  deposition: DepositionWhereClause
  depositionId: IntComparators
  id: IntComparators
  authorListOrder: IntComparators
  orcid: StrComparators
  name: StrComparators
  email: StrComparators
  affiliationName: StrComparators
  affiliationAddress: StrComparators
  affiliationIdentifier: StrComparators
  correspondingAuthorStatus: BoolComparators
  primaryAuthorStatus: BoolComparators
}

input StrComparators {
  _eq: String
  _neq: String
  _in: [String!]
  _nin: [String!]
  _is_null: Boolean
  _gt: String
  _gte: String
  _lt: String
  _lte: String
  _like: String
  _nlike: String
  _ilike: String
  _nilike: String
  _regex: String
  _nregex: String
  _iregex: String
  _niregex: String
}

input BoolComparators {
  _eq: Boolean
  _neq: Boolean
  _in: [Boolean!]
  _nin: [Boolean!]
  _is_null: Boolean
}

input FrameWhereClause {
  deposition: DepositionWhereClause
  depositionId: IntComparators
  run: RunWhereClause
  runId: IntComparators
  rawAngle: FloatComparators
  acquisitionOrder: IntComparators
  dose: FloatComparators
  isGainCorrected: BoolComparators
  s3FramePath: StrComparators
  httpsFramePath: StrComparators
  id: IntComparators
}

input FloatComparators {
  _eq: Float
  _neq: Float
  _in: [Float!]
  _nin: [Float!]
  _gt: Float
  _gte: Float
  _lt: Float
  _lte: Float
  _is_null: Boolean
}

input TiltseriesWhereClause {
  alignments: AlignmentWhereClause
  run: RunWhereClause
  runId: IntComparators
  deposition: DepositionWhereClause
  depositionId: IntComparators
  s3OmezarrDir: StrComparators
  s3MrcFile: StrComparators
  httpsOmezarrDir: StrComparators
  httpsMrcFile: StrComparators
  s3AngleList: StrComparators
  httpsAngleList: StrComparators
  accelerationVoltage: IntComparators
  sphericalAberrationConstant: FloatComparators
  microscopeManufacturer: Tiltseries_microscope_manufacturer_enumEnumComparators
  microscopeModel: StrComparators
  microscopeEnergyFilter: StrComparators
  microscopePhasePlate: StrComparators
  microscopeImageCorrector: StrComparators
  microscopeAdditionalInfo: StrComparators
  cameraManufacturer: StrComparators
  cameraModel: StrComparators
  tiltMin: FloatComparators
  tiltMax: FloatComparators
  tiltRange: FloatComparators
  tiltStep: FloatComparators
  tiltingScheme: StrComparators
  tiltAxis: FloatComparators
  totalFlux: FloatComparators
  dataAcquisitionSoftware: StrComparators
  relatedEmpiarEntry: StrComparators
  binningFromFrames: FloatComparators
  tiltSeriesQuality: IntComparators
  isAligned: BoolComparators
  pixelSpacing: FloatComparators
  alignedTiltseriesBinning: IntComparators
  id: IntComparators
}

input Tiltseries_microscope_manufacturer_enumEnumComparators {
  _eq: tiltseries_microscope_manufacturer_enum
  _neq: tiltseries_microscope_manufacturer_enum
  _in: [tiltseries_microscope_manufacturer_enum!]
  _nin: [tiltseries_microscope_manufacturer_enum!]
  _gt: tiltseries_microscope_manufacturer_enum
  _gte: tiltseries_microscope_manufacturer_enum
  _lt: tiltseries_microscope_manufacturer_enum
  _lte: tiltseries_microscope_manufacturer_enum
  _is_null: Boolean
}

enum tiltseries_microscope_manufacturer_enum {
  FEI
  TFS
  JEOL
  SIMULATED
}

input TomogramWhereClause {
  alignment: AlignmentWhereClause
  alignmentId: IntComparators
  authors: TomogramAuthorWhereClause
  deposition: DepositionWhereClause
  depositionId: IntComparators
  run: RunWhereClause
  runId: IntComparators
  tomogramVoxelSpacing: TomogramVoxelSpacingWhereClause
  tomogramVoxelSpacingId: IntComparators
  name: StrComparators
  sizeX: IntComparators
  sizeY: IntComparators
  sizeZ: IntComparators
  voxelSpacing: FloatComparators
  fiducialAlignmentStatus: Fiducial_alignment_status_enumEnumComparators
  reconstructionMethod: Tomogram_reconstruction_method_enumEnumComparators
  processing: Tomogram_processing_enumEnumComparators
  tomogramVersion: FloatComparators
  processingSoftware: StrComparators
  reconstructionSoftware: StrComparators
  isPortalStandard: BoolComparators
  isAuthorSubmitted: BoolComparators
  isVisualizationDefault: BoolComparators
  s3OmezarrDir: StrComparators
  httpsOmezarrDir: StrComparators
  s3MrcFile: StrComparators
  httpsMrcFile: StrComparators
  scale0Dimensions: StrComparators
  scale1Dimensions: StrComparators
  scale2Dimensions: StrComparators
  ctfCorrected: BoolComparators
  offsetX: IntComparators
  offsetY: IntComparators
  offsetZ: IntComparators
  keyPhotoUrl: StrComparators
  keyPhotoThumbnailUrl: StrComparators
  neuroglancerConfig: StrComparators
  publications: StrComparators
  relatedDatabaseEntries: StrComparators
  id: IntComparators
  depositionDate: DatetimeComparators
  releaseDate: DatetimeComparators
  lastModifiedDate: DatetimeComparators
}

input TomogramAuthorWhereClause {
  tomogram: TomogramWhereClause
  tomogramId: IntComparators
  id: IntComparators
  authorListOrder: IntComparators
  orcid: StrComparators
  name: StrComparators
  email: StrComparators
  affiliationName: StrComparators
  affiliationAddress: StrComparators
  affiliationIdentifier: StrComparators
  correspondingAuthorStatus: BoolComparators
  primaryAuthorStatus: BoolComparators
}

input TomogramVoxelSpacingWhereClause {
  annotationFiles: AnnotationFileWhereClause
  run: RunWhereClause
  runId: IntComparators
  tomograms: TomogramWhereClause
  voxelSpacing: FloatComparators
  s3Prefix: StrComparators
  httpsPrefix: StrComparators
  id: IntComparators
}

input Fiducial_alignment_status_enumEnumComparators {
  _eq: fiducial_alignment_status_enum
  _neq: fiducial_alignment_status_enum
  _in: [fiducial_alignment_status_enum!]
  _nin: [fiducial_alignment_status_enum!]
  _gt: fiducial_alignment_status_enum
  _gte: fiducial_alignment_status_enum
  _lt: fiducial_alignment_status_enum
  _lte: fiducial_alignment_status_enum
  _is_null: Boolean
}

enum fiducial_alignment_status_enum {
  FIDUCIAL
  NON_FIDUCIAL
}

input Tomogram_reconstruction_method_enumEnumComparators {
  _eq: tomogram_reconstruction_method_enum
  _neq: tomogram_reconstruction_method_enum
  _in: [tomogram_reconstruction_method_enum!]
  _nin: [tomogram_reconstruction_method_enum!]
  _gt: tomogram_reconstruction_method_enum
  _gte: tomogram_reconstruction_method_enum
  _lt: tomogram_reconstruction_method_enum
  _lte: tomogram_reconstruction_method_enum
  _is_null: Boolean
}

enum tomogram_reconstruction_method_enum {
  SART
  Fourier_Space
  SIRT
  WBP
  Unknown
}

input Tomogram_processing_enumEnumComparators {
  _eq: tomogram_processing_enum
  _neq: tomogram_processing_enum
  _in: [tomogram_processing_enum!]
  _nin: [tomogram_processing_enum!]
  _gt: tomogram_processing_enum
  _gte: tomogram_processing_enum
  _lt: tomogram_processing_enum
  _lte: tomogram_processing_enum
  _is_null: Boolean
}

enum tomogram_processing_enum {
  denoised
  filtered
  raw
}

input DatetimeComparators {
  _eq: DateTime
  _neq: DateTime
  _in: [DateTime!]
  _nin: [DateTime!]
  _gt: DateTime
  _gte: DateTime
  _lt: DateTime
  _lte: DateTime
  _is_null: Boolean
}

"""Date with time (isoformat)"""
scalar DateTime

input DepositionTypeWhereClause {
  deposition: DepositionWhereClause
  depositionId: IntComparators
  type: Deposition_types_enumEnumComparators
  id: IntComparators
}

input Deposition_types_enumEnumComparators {
  _eq: deposition_types_enum
  _neq: deposition_types_enum
  _in: [deposition_types_enum!]
  _nin: [deposition_types_enum!]
  _gt: deposition_types_enum
  _gte: deposition_types_enum
  _lt: deposition_types_enum
  _lte: deposition_types_enum
  _is_null: Boolean
}

enum deposition_types_enum {
  annotation
  dataset
  tomogram
}

input DatasetFundingWhereClause {
  dataset: DatasetWhereClause
  datasetId: IntComparators
  fundingAgencyName: StrComparators
  grantId: StrComparators
  id: IntComparators
}

input DatasetAuthorWhereClause {
  dataset: DatasetWhereClause
  datasetId: IntComparators
  id: IntComparators
  authorListOrder: IntComparators
  orcid: StrComparators
  name: StrComparators
  email: StrComparators
  affiliationName: StrComparators
  affiliationAddress: StrComparators
  affiliationIdentifier: StrComparators
  correspondingAuthorStatus: BoolComparators
  primaryAuthorStatus: BoolComparators
}

input Sample_type_enumEnumComparators {
  _eq: sample_type_enum
  _neq: sample_type_enum
  _in: [sample_type_enum!]
  _nin: [sample_type_enum!]
  _gt: sample_type_enum
  _gte: sample_type_enum
  _lt: sample_type_enum
  _lte: sample_type_enum
  _is_null: Boolean
}

enum sample_type_enum {
  cell
  tissue
  organism
  organelle
  virus
  in_vitro
  in_silico
  other
}

input GainFileWhereClause {
  run: RunWhereClause
  runId: IntComparators
  s3FilePath: StrComparators
  httpsFilePath: StrComparators
  id: IntComparators
}

input FrameAcquisitionFileWhereClause {
  run: RunWhereClause
  runId: IntComparators
  s3MdocPath: StrComparators
  httpsMdocPath: StrComparators
  id: IntComparators
}

input AnnotationMethodLinkWhereClause {
  annotation: AnnotationWhereClause
  annotationId: IntComparators
  linkType: Annotation_method_link_type_enumEnumComparators
  name: StrComparators
  link: StrComparators
  id: IntComparators
}

input Annotation_method_link_type_enumEnumComparators {
  _eq: annotation_method_link_type_enum
  _neq: annotation_method_link_type_enum
  _in: [annotation_method_link_type_enum!]
  _nin: [annotation_method_link_type_enum!]
  _gt: annotation_method_link_type_enum
  _gte: annotation_method_link_type_enum
  _lt: annotation_method_link_type_enum
  _lte: annotation_method_link_type_enum
  _is_null: Boolean
}

enum annotation_method_link_type_enum {
  documentation
  models_weights
  other
  source_code
  website
}

input AnnotationAuthorWhereClause {
  annotation: AnnotationWhereClause
  annotationId: IntComparators
  id: IntComparators
  authorListOrder: IntComparators
  orcid: StrComparators
  name: StrComparators
  email: StrComparators
  affiliationName: StrComparators
  affiliationAddress: StrComparators
  affiliationIdentifier: StrComparators
  correspondingAuthorStatus: BoolComparators
  primaryAuthorStatus: BoolComparators
}

input Annotation_method_type_enumEnumComparators {
  _eq: annotation_method_type_enum
  _neq: annotation_method_type_enum
  _in: [annotation_method_type_enum!]
  _nin: [annotation_method_type_enum!]
  _gt: annotation_method_type_enum
  _gte: annotation_method_type_enum
  _lt: annotation_method_type_enum
  _lte: annotation_method_type_enum
  _is_null: Boolean
}

enum annotation_method_type_enum {
  manual
  automated
  hybrid
  simulated
}

input Annotation_file_shape_type_enumEnumComparators {
  _eq: annotation_file_shape_type_enum
  _neq: annotation_file_shape_type_enum
  _in: [annotation_file_shape_type_enum!]
  _nin: [annotation_file_shape_type_enum!]
  _gt: annotation_file_shape_type_enum
  _gte: annotation_file_shape_type_enum
  _lt: annotation_file_shape_type_enum
  _lte: annotation_file_shape_type_enum
  _is_null: Boolean
}

enum annotation_file_shape_type_enum {
  SegmentationMask
  OrientedPoint
  Point
  InstanceSegmentation
  Mesh
}

input Annotation_file_source_enumEnumComparators {
  _eq: annotation_file_source_enum
  _neq: annotation_file_source_enum
  _in: [annotation_file_source_enum!]
  _nin: [annotation_file_source_enum!]
  _gt: annotation_file_source_enum
  _gte: annotation_file_source_enum
  _lt: annotation_file_source_enum
  _lte: annotation_file_source_enum
  _is_null: Boolean
}

enum annotation_file_source_enum {
  dataset_author
  community
  portal_standard
}

input PerSectionAlignmentParametersWhereClause {
  alignment: AlignmentWhereClause
  alignmentId: IntComparators
  zIndex: IntComparators
  xOffset: FloatComparators
  yOffset: FloatComparators
  volumeXRotation: FloatComparators
  tiltAngle: FloatComparators
  id: IntComparators
}

input Alignment_type_enumEnumComparators {
  _eq: alignment_type_enum
  _neq: alignment_type_enum
  _in: [alignment_type_enum!]
  _nin: [alignment_type_enum!]
  _gt: alignment_type_enum
  _gte: alignment_type_enum
  _lt: alignment_type_enum
  _lte: alignment_type_enum
  _is_null: Boolean
}

enum alignment_type_enum {
  LOCAL
  GLOBAL
}

input Alignment_method_type_enumEnumComparators {
  _eq: alignment_method_type_enum
  _neq: alignment_method_type_enum
  _in: [alignment_method_type_enum!]
  _nin: [alignment_method_type_enum!]
  _gt: alignment_method_type_enum
  _gte: alignment_method_type_enum
  _lt: alignment_method_type_enum
  _lte: alignment_method_type_enum
  _is_null: Boolean
}

enum alignment_method_type_enum {
  projection_matching
  patch_tracking
  fiducial_based
}

input AlignmentOrderByClause {
  deposition: DepositionOrderByClause
  tiltseries: TiltseriesOrderByClause
  run: RunOrderByClause
  alignmentType: orderBy
  alignmentMethod: orderBy
  volumeXDimension: orderBy
  volumeYDimension: orderBy
  volumeZDimension: orderBy
  volumeXOffset: orderBy
  volumeYOffset: orderBy
  volumeZOffset: orderBy
  xRotationOffset: orderBy
  tiltOffset: orderBy
  affineTransformationMatrix: orderBy
  s3AlignmentMetadata: orderBy
  httpsAlignmentMetadata: orderBy
  isPortalStandard: orderBy
  id: orderBy
}

input DepositionOrderByClause {
  title: orderBy
  description: orderBy
  depositionPublications: orderBy
  relatedDatabaseEntries: orderBy
  depositionDate: orderBy
  releaseDate: orderBy
  lastModifiedDate: orderBy
  keyPhotoUrl: orderBy
  keyPhotoThumbnailUrl: orderBy
  id: orderBy
}

enum orderBy {
  asc
  asc_nulls_first
  asc_nulls_last
  desc
  desc_nulls_first
  desc_nulls_last
}

input TiltseriesOrderByClause {
  run: RunOrderByClause
  deposition: DepositionOrderByClause
  s3OmezarrDir: orderBy
  s3MrcFile: orderBy
  httpsOmezarrDir: orderBy
  httpsMrcFile: orderBy
  s3AngleList: orderBy
  httpsAngleList: orderBy
  accelerationVoltage: orderBy
  sphericalAberrationConstant: orderBy
  microscopeManufacturer: orderBy
  microscopeModel: orderBy
  microscopeEnergyFilter: orderBy
  microscopePhasePlate: orderBy
  microscopeImageCorrector: orderBy
  microscopeAdditionalInfo: orderBy
  cameraManufacturer: orderBy
  cameraModel: orderBy
  tiltMin: orderBy
  tiltMax: orderBy
  tiltRange: orderBy
  tiltStep: orderBy
  tiltingScheme: orderBy
  tiltAxis: orderBy
  totalFlux: orderBy
  dataAcquisitionSoftware: orderBy
  relatedEmpiarEntry: orderBy
  binningFromFrames: orderBy
  tiltSeriesQuality: orderBy
  isAligned: orderBy
  pixelSpacing: orderBy
  alignedTiltseriesBinning: orderBy
  id: orderBy
}

input RunOrderByClause {
  dataset: DatasetOrderByClause
  name: orderBy
  s3Prefix: orderBy
  httpsPrefix: orderBy
  id: orderBy
}

input DatasetOrderByClause {
  deposition: DepositionOrderByClause
  title: orderBy
  description: orderBy
  organismName: orderBy
  organismTaxid: orderBy
  tissueName: orderBy
  tissueId: orderBy
  cellName: orderBy
  cellTypeId: orderBy
  cellStrainName: orderBy
  cellStrainId: orderBy
  sampleType: orderBy
  samplePreparation: orderBy
  gridPreparation: orderBy
  otherSetup: orderBy
  keyPhotoUrl: orderBy
  keyPhotoThumbnailUrl: orderBy
  cellComponentName: orderBy
  cellComponentId: orderBy
  depositionDate: orderBy
  releaseDate: orderBy
  lastModifiedDate: orderBy
  datasetPublications: orderBy
  relatedDatabaseEntries: orderBy
  s3Prefix: orderBy
  httpsPrefix: orderBy
  id: orderBy
}

"""Shapes associated with an annotation"""
type AnnotationShape implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """Numeric identifier (May change!)"""
  id: Int!
  annotation(where: AnnotationWhereClause = null, orderBy: [AnnotationOrderByClause!] = []): Annotation
  annotationId: Int
  annotationFiles(
    where: AnnotationFileWhereClause = null
    orderBy: [AnnotationFileOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AnnotationFileConnection!
  annotationFilesAggregate(where: AnnotationFileWhereClause = null): AnnotationFileAggregate

  """
  The shape of the annotation (SegmentationMask, OrientedPoint, Point, InstanceSegmentation, Mesh)
  """
  shapeType: annotation_file_shape_type_enum
}

"""Metadata for an annotation"""
type Annotation implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """Numeric identifier (May change!)"""
  id: Int!
  run(where: RunWhereClause = null, orderBy: [RunOrderByClause!] = []): Run
  runId: Int
  annotationShapes(
    where: AnnotationShapeWhereClause = null
    orderBy: [AnnotationShapeOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AnnotationShapeConnection!
  annotationShapesAggregate(where: AnnotationShapeWhereClause = null): AnnotationShapeAggregate
  methodLinks(
    where: AnnotationMethodLinkWhereClause = null
    orderBy: [AnnotationMethodLinkOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AnnotationMethodLinkConnection!
  methodLinksAggregate(where: AnnotationMethodLinkWhereClause = null): AnnotationMethodLinkAggregate
  authors(
    where: AnnotationAuthorWhereClause = null
    orderBy: [AnnotationAuthorOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AnnotationAuthorConnection!
  authorsAggregate(where: AnnotationAuthorWhereClause = null): AnnotationAuthorAggregate
  deposition(where: DepositionWhereClause = null, orderBy: [DepositionOrderByClause!] = []): Deposition
  depositionId: Int

  """S3 path for the metadata json file for this annotation"""
  s3MetadataPath: String!

  """HTTPS path for the metadata json file for this annotation"""
  httpsMetadataPath: String!

  """
  DOIs for publications that describe the dataset. Use a comma to separate multiple DOIs.
  """
  annotationPublication: String

  """
  Describe how the annotation is made (e.g. Manual, crYoLO, Positive Unlabeled Learning, template matching)
  """
  annotationMethod: String!

  """
  Whether an annotation is considered ground truth, as determined by the annotator.
  """
  groundTruthStatus: Boolean

  """
  Gene Ontology Cellular Component identifier or UniProtKB accession for the annotation object.
  """
  objectId: String!

  """
  Name of the object being annotated (e.g. ribosome, nuclear pore complex, actin filament, membrane)
  """
  objectName: String!

  """
  A textual description of the annotation object, can be a longer description to include additional information not covered by the Annotation object name and state.
  """
  objectDescription: String

  """Molecule state annotated (e.g. open, closed)"""
  objectState: String

  """Number of objects identified"""
  objectCount: Int

  """
  Describe the confidence level of the annotation. Precision is defined as the % of annotation objects being true positive
  """
  confidencePrecision: Float

  """
  Describe the confidence level of the annotation. Recall is defined as the % of true positives being annotated correctly
  """
  confidenceRecall: Float

  """Annotation filename used as ground truth for precision and recall"""
  groundTruthUsed: String

  """Software used for generating this annotation"""
  annotationSoftware: String

  """
  Data curator’s subjective choice as the best annotation of the same annotation object ID
  """
  isCuratorRecommended: Boolean

  """
  The method type for generating the annotation (e.g. manual, hybrid, automated)
  """
  methodType: annotation_method_type_enum!

  """Date when an annotation set is initially received by the Data Portal."""
  depositionDate: DateTime!

  """Date when annotation data is made public by the Data Portal."""
  releaseDate: DateTime!

  """Date when an annotation was last modified in the Data Portal"""
  lastModifiedDate: DateTime!
}

"""A connection to a list of items."""
type AnnotationShapeConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [AnnotationShapeEdge!]!
}

"""An edge in a connection."""
type AnnotationShapeEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: AnnotationShape!
}

input AnnotationShapeOrderByClause {
  annotation: AnnotationOrderByClause
  shapeType: orderBy
  id: orderBy
}

input AnnotationOrderByClause {
  run: RunOrderByClause
  deposition: DepositionOrderByClause
  s3MetadataPath: orderBy
  httpsMetadataPath: orderBy
  annotationPublication: orderBy
  annotationMethod: orderBy
  groundTruthStatus: orderBy
  objectId: orderBy
  objectName: orderBy
  objectDescription: orderBy
  objectState: orderBy
  objectCount: orderBy
  confidencePrecision: orderBy
  confidenceRecall: orderBy
  groundTruthUsed: orderBy
  annotationSoftware: orderBy
  isCuratorRecommended: orderBy
  methodType: orderBy
  depositionDate: orderBy
  releaseDate: orderBy
  lastModifiedDate: orderBy
  id: orderBy
}

type AnnotationShapeAggregate {
  aggregate: [AnnotationShapeAggregateFunctions!]
}

type AnnotationShapeAggregateFunctions {
  sum: AnnotationShapeNumericalColumns
  avg: AnnotationShapeNumericalColumns
  stddev: AnnotationShapeNumericalColumns
  variance: AnnotationShapeNumericalColumns
  min: AnnotationShapeMinMaxColumns
  max: AnnotationShapeMinMaxColumns
  groupBy: AnnotationShapeGroupByOptions
  count(distinct: Boolean = false, columns: AnnotationShapeCountColumns = null): Int
}

type AnnotationShapeNumericalColumns {
  id: Int
}

type AnnotationShapeMinMaxColumns {
  id: Int
}

type AnnotationShapeGroupByOptions {
  annotation: AnnotationGroupByOptions
  shapeType: annotation_file_shape_type_enum
  id: Int
}

type AnnotationGroupByOptions {
  run: RunGroupByOptions
  deposition: DepositionGroupByOptions
  s3MetadataPath: String
  httpsMetadataPath: String
  annotationPublication: String
  annotationMethod: String
  groundTruthStatus: Boolean
  objectId: String
  objectName: String
  objectDescription: String
  objectState: String
  objectCount: Int
  confidencePrecision: Float
  confidenceRecall: Float
  groundTruthUsed: String
  annotationSoftware: String
  isCuratorRecommended: Boolean
  methodType: annotation_method_type_enum
  depositionDate: DateTime
  releaseDate: DateTime
  lastModifiedDate: DateTime
  id: Int
}

type RunGroupByOptions {
  dataset: DatasetGroupByOptions
  name: String
  s3Prefix: String
  httpsPrefix: String
  id: Int
}

type DatasetGroupByOptions {
  deposition: DepositionGroupByOptions
  title: String
  description: String
  organismName: String
  organismTaxid: Int
  tissueName: String
  tissueId: String
  cellName: String
  cellTypeId: String
  cellStrainName: String
  cellStrainId: String
  sampleType: sample_type_enum
  samplePreparation: String
  gridPreparation: String
  otherSetup: String
  keyPhotoUrl: String
  keyPhotoThumbnailUrl: String
  cellComponentName: String
  cellComponentId: String
  depositionDate: DateTime
  releaseDate: DateTime
  lastModifiedDate: DateTime
  datasetPublications: String
  relatedDatabaseEntries: String
  s3Prefix: String
  httpsPrefix: String
  id: Int
}

type DepositionGroupByOptions {
  title: String
  description: String
  depositionPublications: String
  relatedDatabaseEntries: String
  depositionDate: DateTime
  releaseDate: DateTime
  lastModifiedDate: DateTime
  keyPhotoUrl: String
  keyPhotoThumbnailUrl: String
  id: Int
}

enum AnnotationShapeCountColumns {
  annotation
  annotationFiles
  shapeType
  id
}

"""A connection to a list of items."""
type AnnotationMethodLinkConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [AnnotationMethodLinkEdge!]!
}

"""An edge in a connection."""
type AnnotationMethodLinkEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: AnnotationMethodLink!
}

"""
A set of links to models, source code, documentation, etc referenced by annotation method
"""
type AnnotationMethodLink implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """Numeric identifier (May change!)"""
  id: Int!
  annotation(where: AnnotationWhereClause = null, orderBy: [AnnotationOrderByClause!] = []): Annotation
  annotationId: Int

  """Type of link (e.g. model, source code, documentation)"""
  linkType: annotation_method_link_type_enum!

  """user readable name of the resource"""
  name: String

  """URL to the resource"""
  link: String!
}

input AnnotationMethodLinkOrderByClause {
  annotation: AnnotationOrderByClause
  linkType: orderBy
  name: orderBy
  link: orderBy
  id: orderBy
}

type AnnotationMethodLinkAggregate {
  aggregate: [AnnotationMethodLinkAggregateFunctions!]
}

type AnnotationMethodLinkAggregateFunctions {
  sum: AnnotationMethodLinkNumericalColumns
  avg: AnnotationMethodLinkNumericalColumns
  stddev: AnnotationMethodLinkNumericalColumns
  variance: AnnotationMethodLinkNumericalColumns
  min: AnnotationMethodLinkMinMaxColumns
  max: AnnotationMethodLinkMinMaxColumns
  groupBy: AnnotationMethodLinkGroupByOptions
  count(distinct: Boolean = false, columns: AnnotationMethodLinkCountColumns = null): Int
}

type AnnotationMethodLinkNumericalColumns {
  id: Int
}

type AnnotationMethodLinkMinMaxColumns {
  name: String
  link: String
  id: Int
}

type AnnotationMethodLinkGroupByOptions {
  annotation: AnnotationGroupByOptions
  linkType: annotation_method_link_type_enum
  name: String
  link: String
  id: Int
}

enum AnnotationMethodLinkCountColumns {
  annotation
  linkType
  name
  link
  id
}

"""A connection to a list of items."""
type AnnotationAuthorConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [AnnotationAuthorEdge!]!
}

"""An edge in a connection."""
type AnnotationAuthorEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: AnnotationAuthor!
}

"""Metadata for an annotation's authors"""
type AnnotationAuthor implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """Numeric identifier (May change!)"""
  id: Int!
  annotation(where: AnnotationWhereClause = null, orderBy: [AnnotationOrderByClause!] = []): Annotation
  annotationId: Int

  """The order in which the author appears in the publication"""
  authorListOrder: Int!

  """A unique, persistent identifier for researchers, provided by ORCID."""
  orcid: String

  """Full name of an annotation author (e.g. Jane Doe)."""
  name: String!

  """Email address for this author"""
  email: String

  """
  Name of the institution an annotator is affiliated with. Sometimes, one annotator may have multiple affiliations.
  """
  affiliationName: String

  """Address of the institution an annotator is affiliated with."""
  affiliationAddress: String

  """
  A unique identifier assigned to the affiliated institution by The Research Organization Registry (ROR).
  """
  affiliationIdentifier: String

  """Indicates whether an annotator is the corresponding author"""
  correspondingAuthorStatus: Boolean

  """
  Indicates whether an author is the main person executing the annotation, especially on manual annotation
  """
  primaryAuthorStatus: Boolean
}

input AnnotationAuthorOrderByClause {
  annotation: AnnotationOrderByClause
  id: orderBy
  authorListOrder: orderBy
  orcid: orderBy
  name: orderBy
  email: orderBy
  affiliationName: orderBy
  affiliationAddress: orderBy
  affiliationIdentifier: orderBy
  correspondingAuthorStatus: orderBy
  primaryAuthorStatus: orderBy
}

type AnnotationAuthorAggregate {
  aggregate: [AnnotationAuthorAggregateFunctions!]
}

type AnnotationAuthorAggregateFunctions {
  sum: AnnotationAuthorNumericalColumns
  avg: AnnotationAuthorNumericalColumns
  stddev: AnnotationAuthorNumericalColumns
  variance: AnnotationAuthorNumericalColumns
  min: AnnotationAuthorMinMaxColumns
  max: AnnotationAuthorMinMaxColumns
  groupBy: AnnotationAuthorGroupByOptions
  count(distinct: Boolean = false, columns: AnnotationAuthorCountColumns = null): Int
}

type AnnotationAuthorNumericalColumns {
  id: Int
  authorListOrder: Int
}

type AnnotationAuthorMinMaxColumns {
  id: Int
  authorListOrder: Int
  orcid: String
  name: String
  email: String
  affiliationName: String
  affiliationAddress: String
  affiliationIdentifier: String
}

type AnnotationAuthorGroupByOptions {
  annotation: AnnotationGroupByOptions
  id: Int
  authorListOrder: Int
  orcid: String
  name: String
  email: String
  affiliationName: String
  affiliationAddress: String
  affiliationIdentifier: String
  correspondingAuthorStatus: Boolean
  primaryAuthorStatus: Boolean
}

enum AnnotationAuthorCountColumns {
  annotation
  id
  authorListOrder
  orcid
  name
  email
  affiliationName
  affiliationAddress
  affiliationIdentifier
  correspondingAuthorStatus
  primaryAuthorStatus
}

"""Deposition metadata"""
type Deposition implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """Numeric identifier (May change!)"""
  id: Int!
  authors(
    where: DepositionAuthorWhereClause = null
    orderBy: [DepositionAuthorOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): DepositionAuthorConnection!
  authorsAggregate(where: DepositionAuthorWhereClause = null): DepositionAuthorAggregate
  alignments(
    where: AlignmentWhereClause = null
    orderBy: [AlignmentOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AlignmentConnection!
  alignmentsAggregate(where: AlignmentWhereClause = null): AlignmentAggregate
  annotations(
    where: AnnotationWhereClause = null
    orderBy: [AnnotationOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AnnotationConnection!
  annotationsAggregate(where: AnnotationWhereClause = null): AnnotationAggregate
  datasets(
    where: DatasetWhereClause = null
    orderBy: [DatasetOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): DatasetConnection!
  datasetsAggregate(where: DatasetWhereClause = null): DatasetAggregate
  frames(
    where: FrameWhereClause = null
    orderBy: [FrameOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): FrameConnection!
  framesAggregate(where: FrameWhereClause = null): FrameAggregate
  tiltseries(
    where: TiltseriesWhereClause = null
    orderBy: [TiltseriesOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): TiltseriesConnection!
  tiltseriesAggregate(where: TiltseriesWhereClause = null): TiltseriesAggregate
  tomograms(
    where: TomogramWhereClause = null
    orderBy: [TomogramOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): TomogramConnection!
  tomogramsAggregate(where: TomogramWhereClause = null): TomogramAggregate

  """Title for the deposition"""
  title: String!

  """Description for the deposition"""
  description: String!
  depositionTypes(
    where: DepositionTypeWhereClause = null
    orderBy: [DepositionTypeOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): DepositionTypeConnection!
  depositionTypesAggregate(where: DepositionTypeWhereClause = null): DepositionTypeAggregate

  """The publications related to this deposition"""
  depositionPublications: String

  """The related database entries to this deposition"""
  relatedDatabaseEntries: String

  """The date the deposition was deposited"""
  depositionDate: DateTime!

  """The date the deposition was released"""
  releaseDate: DateTime!

  """The date the deposition was last modified"""
  lastModifiedDate: DateTime!

  """URL for the deposition preview image."""
  keyPhotoUrl: String

  """URL for the deposition thumbnail image."""
  keyPhotoThumbnailUrl: String
}

"""A connection to a list of items."""
type DepositionAuthorConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [DepositionAuthorEdge!]!
}

"""An edge in a connection."""
type DepositionAuthorEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: DepositionAuthor!
}

"""Authors for a deposition"""
type DepositionAuthor implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """Numeric identifier (May change!)"""
  id: Int!
  deposition(where: DepositionWhereClause = null, orderBy: [DepositionOrderByClause!] = []): Deposition
  depositionId: Int!

  """The order in which the author appears in the publication"""
  authorListOrder: Int!

  """A unique, persistent identifier for researchers, provided by ORCID."""
  orcid: String

  """Full name of a deposition author (e.g. Jane Doe)."""
  name: String!

  """Email address for this author"""
  email: String

  """Name of the institutions an author is affiliated with. Comma separated"""
  affiliationName: String

  """Address of the institution an author is affiliated with."""
  affiliationAddress: String

  """
  A unique identifier assigned to the affiliated institution by The Research Organization Registry (ROR).
  """
  affiliationIdentifier: String

  """Indicates whether an author is the corresponding author"""
  correspondingAuthorStatus: Boolean

  """Indicates whether an author is the main person creating the deposition"""
  primaryAuthorStatus: Boolean
}

input DepositionAuthorOrderByClause {
  deposition: DepositionOrderByClause
  id: orderBy
  authorListOrder: orderBy
  orcid: orderBy
  name: orderBy
  email: orderBy
  affiliationName: orderBy
  affiliationAddress: orderBy
  affiliationIdentifier: orderBy
  correspondingAuthorStatus: orderBy
  primaryAuthorStatus: orderBy
}

type DepositionAuthorAggregate {
  aggregate: [DepositionAuthorAggregateFunctions!]
}

type DepositionAuthorAggregateFunctions {
  sum: DepositionAuthorNumericalColumns
  avg: DepositionAuthorNumericalColumns
  stddev: DepositionAuthorNumericalColumns
  variance: DepositionAuthorNumericalColumns
  min: DepositionAuthorMinMaxColumns
  max: DepositionAuthorMinMaxColumns
  groupBy: DepositionAuthorGroupByOptions
  count(distinct: Boolean = false, columns: DepositionAuthorCountColumns = null): Int
}

type DepositionAuthorNumericalColumns {
  id: Int
  authorListOrder: Int
}

type DepositionAuthorMinMaxColumns {
  id: Int
  authorListOrder: Int
  orcid: String
  name: String
  email: String
  affiliationName: String
  affiliationAddress: String
  affiliationIdentifier: String
}

type DepositionAuthorGroupByOptions {
  deposition: DepositionGroupByOptions
  id: Int
  authorListOrder: Int
  orcid: String
  name: String
  email: String
  affiliationName: String
  affiliationAddress: String
  affiliationIdentifier: String
  correspondingAuthorStatus: Boolean
  primaryAuthorStatus: Boolean
}

enum DepositionAuthorCountColumns {
  deposition
  id
  authorListOrder
  orcid
  name
  email
  affiliationName
  affiliationAddress
  affiliationIdentifier
  correspondingAuthorStatus
  primaryAuthorStatus
}

type AlignmentAggregate {
  aggregate: [AlignmentAggregateFunctions!]
}

type AlignmentAggregateFunctions {
  sum: AlignmentNumericalColumns
  avg: AlignmentNumericalColumns
  stddev: AlignmentNumericalColumns
  variance: AlignmentNumericalColumns
  min: AlignmentMinMaxColumns
  max: AlignmentMinMaxColumns
  groupBy: AlignmentGroupByOptions
  count(distinct: Boolean = false, columns: AlignmentCountColumns = null): Int
}

type AlignmentNumericalColumns {
  volumeXDimension: Float
  volumeYDimension: Float
  volumeZDimension: Float
  volumeXOffset: Float
  volumeYOffset: Float
  volumeZOffset: Float
  xRotationOffset: Float
  tiltOffset: Float
  id: Int
}

type AlignmentMinMaxColumns {
  volumeXDimension: Float
  volumeYDimension: Float
  volumeZDimension: Float
  volumeXOffset: Float
  volumeYOffset: Float
  volumeZOffset: Float
  xRotationOffset: Float
  tiltOffset: Float
  affineTransformationMatrix: String
  s3AlignmentMetadata: String
  httpsAlignmentMetadata: String
  id: Int
}

type AlignmentGroupByOptions {
  deposition: DepositionGroupByOptions
  tiltseries: TiltseriesGroupByOptions
  run: RunGroupByOptions
  alignmentType: alignment_type_enum
  alignmentMethod: alignment_method_type_enum
  volumeXDimension: Float
  volumeYDimension: Float
  volumeZDimension: Float
  volumeXOffset: Float
  volumeYOffset: Float
  volumeZOffset: Float
  xRotationOffset: Float
  tiltOffset: Float
  affineTransformationMatrix: String
  s3AlignmentMetadata: String
  httpsAlignmentMetadata: String
  isPortalStandard: Boolean
  id: Int
}

type TiltseriesGroupByOptions {
  run: RunGroupByOptions
  deposition: DepositionGroupByOptions
  s3OmezarrDir: String
  s3MrcFile: String
  httpsOmezarrDir: String
  httpsMrcFile: String
  s3AngleList: String
  httpsAngleList: String
  accelerationVoltage: Int
  sphericalAberrationConstant: Float
  microscopeManufacturer: tiltseries_microscope_manufacturer_enum
  microscopeModel: String
  microscopeEnergyFilter: String
  microscopePhasePlate: String
  microscopeImageCorrector: String
  microscopeAdditionalInfo: String
  cameraManufacturer: String
  cameraModel: String
  tiltMin: Float
  tiltMax: Float
  tiltRange: Float
  tiltStep: Float
  tiltingScheme: String
  tiltAxis: Float
  totalFlux: Float
  dataAcquisitionSoftware: String
  relatedEmpiarEntry: String
  binningFromFrames: Float
  tiltSeriesQuality: Int
  isAligned: Boolean
  pixelSpacing: Float
  alignedTiltseriesBinning: Int
  id: Int
}

enum AlignmentCountColumns {
  annotationFiles
  perSectionAlignments
  deposition
  tiltseries
  tomograms
  run
  alignmentType
  alignmentMethod
  volumeXDimension
  volumeYDimension
  volumeZDimension
  volumeXOffset
  volumeYOffset
  volumeZOffset
  xRotationOffset
  tiltOffset
  affineTransformationMatrix
  s3AlignmentMetadata
  httpsAlignmentMetadata
  isPortalStandard
  id
}

"""A connection to a list of items."""
type AnnotationConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [AnnotationEdge!]!
}

"""An edge in a connection."""
type AnnotationEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Annotation!
}

type AnnotationAggregate {
  aggregate: [AnnotationAggregateFunctions!]
}

type AnnotationAggregateFunctions {
  sum: AnnotationNumericalColumns
  avg: AnnotationNumericalColumns
  stddev: AnnotationNumericalColumns
  variance: AnnotationNumericalColumns
  min: AnnotationMinMaxColumns
  max: AnnotationMinMaxColumns
  groupBy: AnnotationGroupByOptions
  count(distinct: Boolean = false, columns: AnnotationCountColumns = null): Int
}

type AnnotationNumericalColumns {
  objectCount: Int
  confidencePrecision: Float
  confidenceRecall: Float
  id: Int
}

type AnnotationMinMaxColumns {
  s3MetadataPath: String
  httpsMetadataPath: String
  annotationPublication: String
  annotationMethod: String
  objectId: String
  objectName: String
  objectDescription: String
  objectState: String
  objectCount: Int
  confidencePrecision: Float
  confidenceRecall: Float
  groundTruthUsed: String
  annotationSoftware: String
  depositionDate: DateTime
  releaseDate: DateTime
  lastModifiedDate: DateTime
  id: Int
}

enum AnnotationCountColumns {
  run
  annotationShapes
  methodLinks
  authors
  deposition
  s3MetadataPath
  httpsMetadataPath
  annotationPublication
  annotationMethod
  groundTruthStatus
  objectId
  objectName
  objectDescription
  objectState
  objectCount
  confidencePrecision
  confidenceRecall
  groundTruthUsed
  annotationSoftware
  isCuratorRecommended
  methodType
  depositionDate
  releaseDate
  lastModifiedDate
  id
}

"""A connection to a list of items."""
type DatasetConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [DatasetEdge!]!
}

"""An edge in a connection."""
type DatasetEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Dataset!
}

"""A collection of imaging experiments on the same organism"""
type Dataset implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """
  An identifier for a CryoET dataset, assigned by the Data Portal. Used to identify the dataset as the directory name in data tree
  """
  id: Int!
  deposition(where: DepositionWhereClause = null, orderBy: [DepositionOrderByClause!] = []): Deposition
  depositionId: Int!
  fundingSources(
    where: DatasetFundingWhereClause = null
    orderBy: [DatasetFundingOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): DatasetFundingConnection!
  fundingSourcesAggregate(where: DatasetFundingWhereClause = null): DatasetFundingAggregate
  authors(
    where: DatasetAuthorWhereClause = null
    orderBy: [DatasetAuthorOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): DatasetAuthorConnection!
  authorsAggregate(where: DatasetAuthorWhereClause = null): DatasetAuthorAggregate
  runs(
    where: RunWhereClause = null
    orderBy: [RunOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): RunConnection!
  runsAggregate(where: RunWhereClause = null): RunAggregate

  """Title of a CryoET dataset"""
  title: String!

  """
  A short description of a CryoET dataset, similar to an abstract for a journal article or dataset.
  """
  description: String!

  """
  Name of the organism from which a biological sample used in a CryoET study is derived from, e.g. homo sapiens
  """
  organismName: String

  """NCBI taxonomy identifier for the organism, e.g. 9606"""
  organismTaxid: Int

  """
  Name of the tissue from which a biological sample used in a CryoET study is derived from.
  """
  tissueName: String

  """UBERON identifier for the tissue"""
  tissueId: String

  """
  Name of the cell from which a biological sample used in a CryoET study is derived from.
  """
  cellName: String

  """Cell Ontology identifier for the cell type"""
  cellTypeId: String

  """Cell line or strain for the sample."""
  cellStrainName: String

  """Link to more information about the cell strain"""
  cellStrainId: String

  """
  Type of samples used in a CryoET study. (cell, tissue, organism, intact organelle, in-vitro mixture, in-silico synthetic data, other)
  """
  sampleType: sample_type_enum

  """Describe how the sample was prepared."""
  samplePreparation: String

  """Describe Cryo-ET grid preparation."""
  gridPreparation: String

  """
  Describe other setup not covered by sample preparation or grid preparation that may make this dataset unique in the same publication
  """
  otherSetup: String

  """URL for the dataset preview image."""
  keyPhotoUrl: String

  """URL for the thumbnail of preview image."""
  keyPhotoThumbnailUrl: String

  """Name of the cellular component"""
  cellComponentName: String

  """
  If the dataset focuses on a specific part of a cell, the subset is included here
  """
  cellComponentId: String

  """Date when a dataset is initially received by the Data Portal."""
  depositionDate: DateTime!

  """Date when a dataset is made available on the Data Portal."""
  releaseDate: DateTime!

  """Date when a released dataset is last modified."""
  lastModifiedDate: DateTime!

  """
  Comma-separated list of DOIs for publications associated with the dataset.
  """
  datasetPublications: String

  """
  If a CryoET dataset is also deposited into another database, enter the database identifier here (e.g. EMPIAR-11445). Use a comma to separate multiple identifiers.
  """
  relatedDatabaseEntries: String

  """The S3 public bucket path where this dataset is contained"""
  s3Prefix: String!

  """The https directory path where this dataset is contained"""
  httpsPrefix: String!
}

"""A connection to a list of items."""
type DatasetFundingConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [DatasetFundingEdge!]!
}

"""An edge in a connection."""
type DatasetFundingEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: DatasetFunding!
}

"""Metadata for a dataset's funding sources"""
type DatasetFunding implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """Numeric identifier (May change!)"""
  id: Int!
  dataset(where: DatasetWhereClause = null, orderBy: [DatasetOrderByClause!] = []): Dataset
  datasetId: Int

  """Name of the funding agency."""
  fundingAgencyName: String

  """Grant identifier provided by the funding agency."""
  grantId: String
}

input DatasetFundingOrderByClause {
  dataset: DatasetOrderByClause
  fundingAgencyName: orderBy
  grantId: orderBy
  id: orderBy
}

type DatasetFundingAggregate {
  aggregate: [DatasetFundingAggregateFunctions!]
}

type DatasetFundingAggregateFunctions {
  sum: DatasetFundingNumericalColumns
  avg: DatasetFundingNumericalColumns
  stddev: DatasetFundingNumericalColumns
  variance: DatasetFundingNumericalColumns
  min: DatasetFundingMinMaxColumns
  max: DatasetFundingMinMaxColumns
  groupBy: DatasetFundingGroupByOptions
  count(distinct: Boolean = false, columns: DatasetFundingCountColumns = null): Int
}

type DatasetFundingNumericalColumns {
  id: Int
}

type DatasetFundingMinMaxColumns {
  fundingAgencyName: String
  grantId: String
  id: Int
}

type DatasetFundingGroupByOptions {
  dataset: DatasetGroupByOptions
  fundingAgencyName: String
  grantId: String
  id: Int
}

enum DatasetFundingCountColumns {
  dataset
  fundingAgencyName
  grantId
  id
}

"""A connection to a list of items."""
type DatasetAuthorConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [DatasetAuthorEdge!]!
}

"""An edge in a connection."""
type DatasetAuthorEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: DatasetAuthor!
}

"""An author of a dataset"""
type DatasetAuthor implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """Numeric identifier (May change!)"""
  id: Int!
  dataset(where: DatasetWhereClause = null, orderBy: [DatasetOrderByClause!] = []): Dataset
  datasetId: Int

  """The order in which the author appears in the publication"""
  authorListOrder: Int!

  """A unique, persistent identifier for researchers, provided by ORCID."""
  orcid: String

  """Full name of an author (e.g. Jane Doe)."""
  name: String!

  """Email address for this author"""
  email: String

  """Name of the institutions an author is affiliated with. Comma separated"""
  affiliationName: String

  """Address of the institution an author is affiliated with."""
  affiliationAddress: String

  """
  A unique identifier assigned to the affiliated institution by The Research Organization Registry (ROR).
  """
  affiliationIdentifier: String

  """Indicates whether an author is the corresponding author"""
  correspondingAuthorStatus: Boolean

  """
  Indicates whether an author is the main person associated with the corresponding dataset
  """
  primaryAuthorStatus: Boolean
}

input DatasetAuthorOrderByClause {
  dataset: DatasetOrderByClause
  id: orderBy
  authorListOrder: orderBy
  orcid: orderBy
  name: orderBy
  email: orderBy
  affiliationName: orderBy
  affiliationAddress: orderBy
  affiliationIdentifier: orderBy
  correspondingAuthorStatus: orderBy
  primaryAuthorStatus: orderBy
}

type DatasetAuthorAggregate {
  aggregate: [DatasetAuthorAggregateFunctions!]
}

type DatasetAuthorAggregateFunctions {
  sum: DatasetAuthorNumericalColumns
  avg: DatasetAuthorNumericalColumns
  stddev: DatasetAuthorNumericalColumns
  variance: DatasetAuthorNumericalColumns
  min: DatasetAuthorMinMaxColumns
  max: DatasetAuthorMinMaxColumns
  groupBy: DatasetAuthorGroupByOptions
  count(distinct: Boolean = false, columns: DatasetAuthorCountColumns = null): Int
}

type DatasetAuthorNumericalColumns {
  id: Int
  authorListOrder: Int
}

type DatasetAuthorMinMaxColumns {
  id: Int
  authorListOrder: Int
  orcid: String
  name: String
  email: String
  affiliationName: String
  affiliationAddress: String
  affiliationIdentifier: String
}

type DatasetAuthorGroupByOptions {
  dataset: DatasetGroupByOptions
  id: Int
  authorListOrder: Int
  orcid: String
  name: String
  email: String
  affiliationName: String
  affiliationAddress: String
  affiliationIdentifier: String
  correspondingAuthorStatus: Boolean
  primaryAuthorStatus: Boolean
}

enum DatasetAuthorCountColumns {
  dataset
  id
  authorListOrder
  orcid
  name
  email
  affiliationName
  affiliationAddress
  affiliationIdentifier
  correspondingAuthorStatus
  primaryAuthorStatus
}

"""A connection to a list of items."""
type RunConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [RunEdge!]!
}

"""An edge in a connection."""
type RunEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Run!
}

type RunAggregate {
  aggregate: [RunAggregateFunctions!]
}

type RunAggregateFunctions {
  sum: RunNumericalColumns
  avg: RunNumericalColumns
  stddev: RunNumericalColumns
  variance: RunNumericalColumns
  min: RunMinMaxColumns
  max: RunMinMaxColumns
  groupBy: RunGroupByOptions
  count(distinct: Boolean = false, columns: RunCountColumns = null): Int
}

type RunNumericalColumns {
  id: Int
}

type RunMinMaxColumns {
  name: String
  s3Prefix: String
  httpsPrefix: String
  id: Int
}

enum RunCountColumns {
  alignments
  annotations
  dataset
  frames
  gainFiles
  frameAcquisitionFiles
  tiltseries
  tomogramVoxelSpacings
  tomograms
  name
  s3Prefix
  httpsPrefix
  id
}

type DatasetAggregate {
  aggregate: [DatasetAggregateFunctions!]
}

type DatasetAggregateFunctions {
  sum: DatasetNumericalColumns
  avg: DatasetNumericalColumns
  stddev: DatasetNumericalColumns
  variance: DatasetNumericalColumns
  min: DatasetMinMaxColumns
  max: DatasetMinMaxColumns
  groupBy: DatasetGroupByOptions
  count(distinct: Boolean = false, columns: DatasetCountColumns = null): Int
}

type DatasetNumericalColumns {
  organismTaxid: Int
  id: Int
}

type DatasetMinMaxColumns {
  title: String
  description: String
  organismName: String
  organismTaxid: Int
  tissueName: String
  tissueId: String
  cellName: String
  cellTypeId: String
  cellStrainName: String
  cellStrainId: String
  samplePreparation: String
  gridPreparation: String
  otherSetup: String
  keyPhotoUrl: String
  keyPhotoThumbnailUrl: String
  cellComponentName: String
  cellComponentId: String
  depositionDate: DateTime
  releaseDate: DateTime
  lastModifiedDate: DateTime
  datasetPublications: String
  relatedDatabaseEntries: String
  s3Prefix: String
  httpsPrefix: String
  id: Int
}

enum DatasetCountColumns {
  deposition
  fundingSources
  authors
  runs
  title
  description
  organismName
  organismTaxid
  tissueName
  tissueId
  cellName
  cellTypeId
  cellStrainName
  cellStrainId
  sampleType
  samplePreparation
  gridPreparation
  otherSetup
  keyPhotoUrl
  keyPhotoThumbnailUrl
  cellComponentName
  cellComponentId
  depositionDate
  releaseDate
  lastModifiedDate
  datasetPublications
  relatedDatabaseEntries
  s3Prefix
  httpsPrefix
  id
}

"""A connection to a list of items."""
type FrameConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [FrameEdge!]!
}

"""An edge in a connection."""
type FrameEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Frame!
}

type Frame implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """Numeric identifier (May change!)"""
  id: Int!
  deposition(where: DepositionWhereClause = null, orderBy: [DepositionOrderByClause!] = []): Deposition
  depositionId: Int!
  run(where: RunWhereClause = null, orderBy: [RunOrderByClause!] = []): Run
  runId: Int!

  """Camera angle for a frame"""
  rawAngle: Float

  """Frame's acquistion order within a tilt experiment"""
  acquisitionOrder: Int

  """The raw camera angle for a frame"""
  dose: Float

  """Whether this frame has been gain corrected"""
  isGainCorrected: Boolean

  """S3 path to the frame file"""
  s3FramePath: String!

  """HTTPS path to the frame file"""
  httpsFramePath: String!
}

input FrameOrderByClause {
  deposition: DepositionOrderByClause
  run: RunOrderByClause
  rawAngle: orderBy
  acquisitionOrder: orderBy
  dose: orderBy
  isGainCorrected: orderBy
  s3FramePath: orderBy
  httpsFramePath: orderBy
  id: orderBy
}

type FrameAggregate {
  aggregate: [FrameAggregateFunctions!]
}

type FrameAggregateFunctions {
  sum: FrameNumericalColumns
  avg: FrameNumericalColumns
  stddev: FrameNumericalColumns
  variance: FrameNumericalColumns
  min: FrameMinMaxColumns
  max: FrameMinMaxColumns
  groupBy: FrameGroupByOptions
  count(distinct: Boolean = false, columns: FrameCountColumns = null): Int
}

type FrameNumericalColumns {
  rawAngle: Float
  acquisitionOrder: Int
  dose: Float
  id: Int
}

type FrameMinMaxColumns {
  rawAngle: Float
  acquisitionOrder: Int
  dose: Float
  s3FramePath: String
  httpsFramePath: String
  id: Int
}

type FrameGroupByOptions {
  deposition: DepositionGroupByOptions
  run: RunGroupByOptions
  rawAngle: Float
  acquisitionOrder: Int
  dose: Float
  isGainCorrected: Boolean
  s3FramePath: String
  httpsFramePath: String
  id: Int
}

enum FrameCountColumns {
  deposition
  run
  rawAngle
  acquisitionOrder
  dose
  isGainCorrected
  s3FramePath
  httpsFramePath
  id
}

"""A connection to a list of items."""
type TiltseriesConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [TiltseriesEdge!]!
}

"""An edge in a connection."""
type TiltseriesEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Tiltseries!
}

type Tiltseries implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """Numeric identifier (May change!)"""
  id: Int!
  alignments(
    where: AlignmentWhereClause = null
    orderBy: [AlignmentOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AlignmentConnection!
  alignmentsAggregate(where: AlignmentWhereClause = null): AlignmentAggregate
  run(where: RunWhereClause = null, orderBy: [RunOrderByClause!] = []): Run
  runId: Int!
  deposition(where: DepositionWhereClause = null, orderBy: [DepositionOrderByClause!] = []): Deposition
  depositionId: Int

  """S3 path to this tiltseries in multiscale OME-Zarr format"""
  s3OmezarrDir: String

  """S3 path to this tiltseries in MRC format (no scaling)"""
  s3MrcFile: String

  """HTTPS path to this tiltseries in multiscale OME-Zarr format"""
  httpsOmezarrDir: String

  """HTTPS path to this tiltseries in MRC format (no scaling)"""
  httpsMrcFile: String

  """S3 path to the angle list file for this tiltseries"""
  s3AngleList: String

  """HTTPS path to the angle list file for this tiltseries"""
  httpsAngleList: String

  """Electron Microscope Accelerator voltage in volts"""
  accelerationVoltage: Int!

  """Spherical Aberration Constant of the objective lens in millimeters"""
  sphericalAberrationConstant: Float!

  """Name of the microscope manufacturer (FEI, TFS, JEOL)"""
  microscopeManufacturer: tiltseries_microscope_manufacturer_enum!

  """Microscope model name"""
  microscopeModel: String!

  """Energy filter setup used"""
  microscopeEnergyFilter: String!

  """Phase plate configuration"""
  microscopePhasePlate: String

  """Image corrector setup"""
  microscopeImageCorrector: String

  """
  Other microscope optical setup information, in addition to energy filter, phase plate and image corrector
  """
  microscopeAdditionalInfo: String

  """Name of the camera manufacturer"""
  cameraManufacturer: String!

  """Camera model name"""
  cameraModel: String!

  """Minimal tilt angle in degrees"""
  tiltMin: Float!

  """Maximal tilt angle in degrees"""
  tiltMax: Float!

  """Total tilt range in degrees"""
  tiltRange: Float!

  """Tilt step in degrees"""
  tiltStep: Float!

  """The order of stage tilting during acquisition of the data"""
  tiltingScheme: String!

  """Rotation angle in degrees"""
  tiltAxis: Float!

  """
  Number of Electrons reaching the specimen in a square Angstrom area for the entire tilt series
  """
  totalFlux: Float!

  """Software used to collect data"""
  dataAcquisitionSoftware: String!

  """
  If a tilt series is deposited into EMPIAR, enter the EMPIAR dataset identifier
  """
  relatedEmpiarEntry: String

  """Describes the binning factor from frames to tilt series file"""
  binningFromFrames: Float

  """
  Author assessment of tilt series quality within the dataset (1-5, 5 is best)
  """
  tiltSeriesQuality: Int!

  """Whether this tilt series is aligned"""
  isAligned: Boolean!

  """Pixel spacing equal in both axes in angstroms"""
  pixelSpacing: Float!

  """Binning factor of the aligned tilt series"""
  alignedTiltseriesBinning: Int
}

type TiltseriesAggregate {
  aggregate: [TiltseriesAggregateFunctions!]
}

type TiltseriesAggregateFunctions {
  sum: TiltseriesNumericalColumns
  avg: TiltseriesNumericalColumns
  stddev: TiltseriesNumericalColumns
  variance: TiltseriesNumericalColumns
  min: TiltseriesMinMaxColumns
  max: TiltseriesMinMaxColumns
  groupBy: TiltseriesGroupByOptions
  count(distinct: Boolean = false, columns: TiltseriesCountColumns = null): Int
}

type TiltseriesNumericalColumns {
  accelerationVoltage: Int
  sphericalAberrationConstant: Float
  tiltMin: Float
  tiltMax: Float
  tiltRange: Float
  tiltStep: Float
  tiltAxis: Float
  totalFlux: Float
  binningFromFrames: Float
  tiltSeriesQuality: Int
  pixelSpacing: Float
  alignedTiltseriesBinning: Int
  id: Int
}

type TiltseriesMinMaxColumns {
  s3OmezarrDir: String
  s3MrcFile: String
  httpsOmezarrDir: String
  httpsMrcFile: String
  s3AngleList: String
  httpsAngleList: String
  accelerationVoltage: Int
  sphericalAberrationConstant: Float
  microscopeModel: String
  microscopeEnergyFilter: String
  microscopePhasePlate: String
  microscopeImageCorrector: String
  microscopeAdditionalInfo: String
  cameraManufacturer: String
  cameraModel: String
  tiltMin: Float
  tiltMax: Float
  tiltRange: Float
  tiltStep: Float
  tiltingScheme: String
  tiltAxis: Float
  totalFlux: Float
  dataAcquisitionSoftware: String
  relatedEmpiarEntry: String
  binningFromFrames: Float
  tiltSeriesQuality: Int
  pixelSpacing: Float
  alignedTiltseriesBinning: Int
  id: Int
}

enum TiltseriesCountColumns {
  alignments
  run
  deposition
  s3OmezarrDir
  s3MrcFile
  httpsOmezarrDir
  httpsMrcFile
  s3AngleList
  httpsAngleList
  accelerationVoltage
  sphericalAberrationConstant
  microscopeManufacturer
  microscopeModel
  microscopeEnergyFilter
  microscopePhasePlate
  microscopeImageCorrector
  microscopeAdditionalInfo
  cameraManufacturer
  cameraModel
  tiltMin
  tiltMax
  tiltRange
  tiltStep
  tiltingScheme
  tiltAxis
  totalFlux
  dataAcquisitionSoftware
  relatedEmpiarEntry
  binningFromFrames
  tiltSeriesQuality
  isAligned
  pixelSpacing
  alignedTiltseriesBinning
  id
}

"""A connection to a list of items."""
type TomogramConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [TomogramEdge!]!
}

"""An edge in a connection."""
type TomogramEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Tomogram!
}

"""Metadata describing a tomogram."""
type Tomogram implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """Numeric identifier (May change!)"""
  id: Int!
  alignment(where: AlignmentWhereClause = null, orderBy: [AlignmentOrderByClause!] = []): Alignment
  alignmentId: Int
  authors(
    where: TomogramAuthorWhereClause = null
    orderBy: [TomogramAuthorOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): TomogramAuthorConnection!
  authorsAggregate(where: TomogramAuthorWhereClause = null): TomogramAuthorAggregate
  deposition(where: DepositionWhereClause = null, orderBy: [DepositionOrderByClause!] = []): Deposition
  depositionId: Int!
  run(where: RunWhereClause = null, orderBy: [RunOrderByClause!] = []): Run
  runId: Int
  tomogramVoxelSpacing(where: TomogramVoxelSpacingWhereClause = null, orderBy: [TomogramVoxelSpacingOrderByClause!] = []): TomogramVoxelSpacing
  tomogramVoxelSpacingId: Int

  """Short name for this tomogram"""
  name: String

  """Number of pixels in the 3D data fast axis"""
  sizeX: Int!

  """Number of pixels in the 3D data medium axis"""
  sizeY: Int!

  """
  Number of pixels in the 3D data slow axis.  This is the image projection direction at zero stage tilt
  """
  sizeZ: Int!

  """Voxel spacing equal in all three axes in angstroms"""
  voxelSpacing: Float!

  """
  Fiducial Alignment status: True = aligned with fiducial False = aligned without fiducial
  """
  fiducialAlignmentStatus: fiducial_alignment_status_enum!

  """Describe reconstruction method (WBP, SART, SIRT)"""
  reconstructionMethod: tomogram_reconstruction_method_enum!

  """Describe additional processing used to derive the tomogram"""
  processing: tomogram_processing_enum!

  """Version of tomogram"""
  tomogramVersion: Float

  """Processing software used to derive the tomogram"""
  processingSoftware: String

  """Name of software used for reconstruction"""
  reconstructionSoftware: String!

  """whether this tomogram adheres to portal standards"""
  isPortalStandard: Boolean

  """
  Whether this tomogram was submitted by the author of the dataset it belongs to.
  """
  isAuthorSubmitted: Boolean

  """
  Data curator’s subjective choice of default tomogram to display in visualization for a run
  """
  isVisualizationDefault: Boolean

  """S3 path to this tomogram in multiscale OME-Zarr format"""
  s3OmezarrDir: String

  """HTTPS path to this tomogram in multiscale OME-Zarr format"""
  httpsOmezarrDir: String

  """S3 path to this tomogram in MRC format (no scaling)"""
  s3MrcFile: String

  """HTTPS path to this tomogram in MRC format (no scaling)"""
  httpsMrcFile: String

  """comma separated x,y,z dimensions of the unscaled tomogram"""
  scale0Dimensions: String

  """comma separated x,y,z dimensions of the scale1 tomogram"""
  scale1Dimensions: String

  """comma separated x,y,z dimensions of the scale2 tomogram"""
  scale2Dimensions: String

  """Whether this tomogram is CTF corrected"""
  ctfCorrected: Boolean

  """x offset data relative to the canonical tomogram in pixels"""
  offsetX: Int!

  """y offset data relative to the canonical tomogram in pixels"""
  offsetY: Int!

  """z offset data relative to the canonical tomogram in pixels"""
  offsetZ: Int!

  """URL for the key photo"""
  keyPhotoUrl: String

  """URL for the thumbnail of key photo"""
  keyPhotoThumbnailUrl: String

  """the compact json of neuroglancer config"""
  neuroglancerConfig: String

  """
  Comma-separated list of DOIs for publications associated with the tomogram.
  """
  publications: String

  """
  If a CryoET tomogram is also deposited into another database, enter the database identifier here (e.g. EMPIAR-11445). Use a comma to separate multiple identifiers.
  """
  relatedDatabaseEntries: String

  """The date a data item was received by the cryoET data portal."""
  depositionDate: DateTime

  """The date a data item was received by the cryoET data portal."""
  releaseDate: DateTime

  """The date a piece of data was last modified on the cryoET data portal."""
  lastModifiedDate: DateTime
}

"""A connection to a list of items."""
type TomogramAuthorConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [TomogramAuthorEdge!]!
}

"""An edge in a connection."""
type TomogramAuthorEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: TomogramAuthor!
}

"""Author of a tomogram"""
type TomogramAuthor implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """Numeric identifier (May change!)"""
  id: Int!
  tomogram(where: TomogramWhereClause = null, orderBy: [TomogramOrderByClause!] = []): Tomogram
  tomogramId: Int

  """The order in which the author appears in the publication"""
  authorListOrder: Int!

  """A unique, persistent identifier for researchers, provided by ORCID."""
  orcid: String

  """Full name of an author (e.g. Jane Doe)."""
  name: String!

  """Email address for this author"""
  email: String

  """Name of the institutions an author is affiliated with. Comma separated"""
  affiliationName: String

  """Address of the institution an author is affiliated with."""
  affiliationAddress: String

  """
  A unique identifier assigned to the affiliated institution by The Research Organization Registry (ROR).
  """
  affiliationIdentifier: String

  """Indicates whether an author is the corresponding author"""
  correspondingAuthorStatus: Boolean

  """Indicates whether an author is the main person creating the tomogram"""
  primaryAuthorStatus: Boolean
}

input TomogramOrderByClause {
  alignment: AlignmentOrderByClause
  deposition: DepositionOrderByClause
  run: RunOrderByClause
  tomogramVoxelSpacing: TomogramVoxelSpacingOrderByClause
  name: orderBy
  sizeX: orderBy
  sizeY: orderBy
  sizeZ: orderBy
  voxelSpacing: orderBy
  fiducialAlignmentStatus: orderBy
  reconstructionMethod: orderBy
  processing: orderBy
  tomogramVersion: orderBy
  processingSoftware: orderBy
  reconstructionSoftware: orderBy
  isPortalStandard: orderBy
  isAuthorSubmitted: orderBy
  isVisualizationDefault: orderBy
  s3OmezarrDir: orderBy
  httpsOmezarrDir: orderBy
  s3MrcFile: orderBy
  httpsMrcFile: orderBy
  scale0Dimensions: orderBy
  scale1Dimensions: orderBy
  scale2Dimensions: orderBy
  ctfCorrected: orderBy
  offsetX: orderBy
  offsetY: orderBy
  offsetZ: orderBy
  keyPhotoUrl: orderBy
  keyPhotoThumbnailUrl: orderBy
  neuroglancerConfig: orderBy
  publications: orderBy
  relatedDatabaseEntries: orderBy
  id: orderBy
  depositionDate: orderBy
  releaseDate: orderBy
  lastModifiedDate: orderBy
}

input TomogramVoxelSpacingOrderByClause {
  run: RunOrderByClause
  voxelSpacing: orderBy
  s3Prefix: orderBy
  httpsPrefix: orderBy
  id: orderBy
}

input TomogramAuthorOrderByClause {
  tomogram: TomogramOrderByClause
  id: orderBy
  authorListOrder: orderBy
  orcid: orderBy
  name: orderBy
  email: orderBy
  affiliationName: orderBy
  affiliationAddress: orderBy
  affiliationIdentifier: orderBy
  correspondingAuthorStatus: orderBy
  primaryAuthorStatus: orderBy
}

type TomogramAuthorAggregate {
  aggregate: [TomogramAuthorAggregateFunctions!]
}

type TomogramAuthorAggregateFunctions {
  sum: TomogramAuthorNumericalColumns
  avg: TomogramAuthorNumericalColumns
  stddev: TomogramAuthorNumericalColumns
  variance: TomogramAuthorNumericalColumns
  min: TomogramAuthorMinMaxColumns
  max: TomogramAuthorMinMaxColumns
  groupBy: TomogramAuthorGroupByOptions
  count(distinct: Boolean = false, columns: TomogramAuthorCountColumns = null): Int
}

type TomogramAuthorNumericalColumns {
  id: Int
  authorListOrder: Int
}

type TomogramAuthorMinMaxColumns {
  id: Int
  authorListOrder: Int
  orcid: String
  name: String
  email: String
  affiliationName: String
  affiliationAddress: String
  affiliationIdentifier: String
}

type TomogramAuthorGroupByOptions {
  tomogram: TomogramGroupByOptions
  id: Int
  authorListOrder: Int
  orcid: String
  name: String
  email: String
  affiliationName: String
  affiliationAddress: String
  affiliationIdentifier: String
  correspondingAuthorStatus: Boolean
  primaryAuthorStatus: Boolean
}

type TomogramGroupByOptions {
  alignment: AlignmentGroupByOptions
  deposition: DepositionGroupByOptions
  run: RunGroupByOptions
  tomogramVoxelSpacing: TomogramVoxelSpacingGroupByOptions
  name: String
  sizeX: Int
  sizeY: Int
  sizeZ: Int
  voxelSpacing: Float
  fiducialAlignmentStatus: fiducial_alignment_status_enum
  reconstructionMethod: tomogram_reconstruction_method_enum
  processing: tomogram_processing_enum
  tomogramVersion: Float
  processingSoftware: String
  reconstructionSoftware: String
  isPortalStandard: Boolean
  isAuthorSubmitted: Boolean
  isVisualizationDefault: Boolean
  s3OmezarrDir: String
  httpsOmezarrDir: String
  s3MrcFile: String
  httpsMrcFile: String
  scale0Dimensions: String
  scale1Dimensions: String
  scale2Dimensions: String
  ctfCorrected: Boolean
  offsetX: Int
  offsetY: Int
  offsetZ: Int
  keyPhotoUrl: String
  keyPhotoThumbnailUrl: String
  neuroglancerConfig: String
  publications: String
  relatedDatabaseEntries: String
  id: Int
  depositionDate: DateTime
  releaseDate: DateTime
  lastModifiedDate: DateTime
}

type TomogramVoxelSpacingGroupByOptions {
  run: RunGroupByOptions
  voxelSpacing: Float
  s3Prefix: String
  httpsPrefix: String
  id: Int
}

enum TomogramAuthorCountColumns {
  tomogram
  id
  authorListOrder
  orcid
  name
  email
  affiliationName
  affiliationAddress
  affiliationIdentifier
  correspondingAuthorStatus
  primaryAuthorStatus
}

"""Voxel spacings for a run"""
type TomogramVoxelSpacing implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """Numeric identifier (May change!)"""
  id: Int!
  annotationFiles(
    where: AnnotationFileWhereClause = null
    orderBy: [AnnotationFileOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AnnotationFileConnection!
  annotationFilesAggregate(where: AnnotationFileWhereClause = null): AnnotationFileAggregate
  run(where: RunWhereClause = null, orderBy: [RunOrderByClause!] = []): Run
  runId: Int
  tomograms(
    where: TomogramWhereClause = null
    orderBy: [TomogramOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): TomogramConnection!
  tomogramsAggregate(where: TomogramWhereClause = null): TomogramAggregate

  """The voxel spacing for the tomograms in this set in angstroms"""
  voxelSpacing: Float!

  """
  The S3 public bucket path where this tomogram voxel spacing is contained
  """
  s3Prefix: String!

  """
  The HTTPS directory path where this tomogram voxel spacing is contained
  """
  httpsPrefix: String!
}

input AnnotationFileOrderByClause {
  alignment: AlignmentOrderByClause
  annotationShape: AnnotationShapeOrderByClause
  tomogramVoxelSpacing: TomogramVoxelSpacingOrderByClause
  format: orderBy
  s3Path: orderBy
  httpsPath: orderBy
  isVisualizationDefault: orderBy
  source: orderBy
  id: orderBy
}

type AnnotationFileAggregate {
  aggregate: [AnnotationFileAggregateFunctions!]
}

type AnnotationFileAggregateFunctions {
  sum: AnnotationFileNumericalColumns
  avg: AnnotationFileNumericalColumns
  stddev: AnnotationFileNumericalColumns
  variance: AnnotationFileNumericalColumns
  min: AnnotationFileMinMaxColumns
  max: AnnotationFileMinMaxColumns
  groupBy: AnnotationFileGroupByOptions
  count(distinct: Boolean = false, columns: AnnotationFileCountColumns = null): Int
}

type AnnotationFileNumericalColumns {
  id: Int
}

type AnnotationFileMinMaxColumns {
  format: String
  s3Path: String
  httpsPath: String
  id: Int
}

type AnnotationFileGroupByOptions {
  alignment: AlignmentGroupByOptions
  annotationShape: AnnotationShapeGroupByOptions
  tomogramVoxelSpacing: TomogramVoxelSpacingGroupByOptions
  format: String
  s3Path: String
  httpsPath: String
  isVisualizationDefault: Boolean
  source: annotation_file_source_enum
  id: Int
}

enum AnnotationFileCountColumns {
  alignment
  annotationShape
  tomogramVoxelSpacing
  format
  s3Path
  httpsPath
  isVisualizationDefault
  source
  id
}

type TomogramAggregate {
  aggregate: [TomogramAggregateFunctions!]
}

type TomogramAggregateFunctions {
  sum: TomogramNumericalColumns
  avg: TomogramNumericalColumns
  stddev: TomogramNumericalColumns
  variance: TomogramNumericalColumns
  min: TomogramMinMaxColumns
  max: TomogramMinMaxColumns
  groupBy: TomogramGroupByOptions
  count(distinct: Boolean = false, columns: TomogramCountColumns = null): Int
}

type TomogramNumericalColumns {
  sizeX: Int
  sizeY: Int
  sizeZ: Int
  voxelSpacing: Float
  tomogramVersion: Float
  offsetX: Int
  offsetY: Int
  offsetZ: Int
  id: Int
}

type TomogramMinMaxColumns {
  name: String
  sizeX: Int
  sizeY: Int
  sizeZ: Int
  voxelSpacing: Float
  tomogramVersion: Float
  processingSoftware: String
  reconstructionSoftware: String
  s3OmezarrDir: String
  httpsOmezarrDir: String
  s3MrcFile: String
  httpsMrcFile: String
  scale0Dimensions: String
  scale1Dimensions: String
  scale2Dimensions: String
  offsetX: Int
  offsetY: Int
  offsetZ: Int
  keyPhotoUrl: String
  keyPhotoThumbnailUrl: String
  neuroglancerConfig: String
  publications: String
  relatedDatabaseEntries: String
  id: Int
  depositionDate: DateTime
  releaseDate: DateTime
  lastModifiedDate: DateTime
}

enum TomogramCountColumns {
  alignment
  authors
  deposition
  run
  tomogramVoxelSpacing
  name
  sizeX
  sizeY
  sizeZ
  voxelSpacing
  fiducialAlignmentStatus
  reconstructionMethod
  processing
  tomogramVersion
  processingSoftware
  reconstructionSoftware
  isPortalStandard
  isAuthorSubmitted
  isVisualizationDefault
  s3OmezarrDir
  httpsOmezarrDir
  s3MrcFile
  httpsMrcFile
  scale0Dimensions
  scale1Dimensions
  scale2Dimensions
  ctfCorrected
  offsetX
  offsetY
  offsetZ
  keyPhotoUrl
  keyPhotoThumbnailUrl
  neuroglancerConfig
  publications
  relatedDatabaseEntries
  id
  depositionDate
  releaseDate
  lastModifiedDate
}

"""A connection to a list of items."""
type DepositionTypeConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [DepositionTypeEdge!]!
}

"""An edge in a connection."""
type DepositionTypeEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: DepositionType!
}

type DepositionType implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """Numeric identifier (May change!)"""
  id: Int!
  deposition(where: DepositionWhereClause = null, orderBy: [DepositionOrderByClause!] = []): Deposition
  depositionId: Int!

  """
  The type of data submitted as a part of this deposition (annotation, dataset, tomogram)
  """
  type: deposition_types_enum
}

input DepositionTypeOrderByClause {
  deposition: DepositionOrderByClause
  type: orderBy
  id: orderBy
}

type DepositionTypeAggregate {
  aggregate: [DepositionTypeAggregateFunctions!]
}

type DepositionTypeAggregateFunctions {
  sum: DepositionTypeNumericalColumns
  avg: DepositionTypeNumericalColumns
  stddev: DepositionTypeNumericalColumns
  variance: DepositionTypeNumericalColumns
  min: DepositionTypeMinMaxColumns
  max: DepositionTypeMinMaxColumns
  groupBy: DepositionTypeGroupByOptions
  count(distinct: Boolean = false, columns: DepositionTypeCountColumns = null): Int
}

type DepositionTypeNumericalColumns {
  id: Int
}

type DepositionTypeMinMaxColumns {
  id: Int
}

type DepositionTypeGroupByOptions {
  deposition: DepositionGroupByOptions
  type: deposition_types_enum
  id: Int
}

enum DepositionTypeCountColumns {
  deposition
  type
  id
}

"""A connection to a list of items."""
type PerSectionAlignmentParametersConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [PerSectionAlignmentParametersEdge!]!
}

"""An edge in a connection."""
type PerSectionAlignmentParametersEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: PerSectionAlignmentParameters!
}

"""Map alignment parameters to tilt series frames"""
type PerSectionAlignmentParameters implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """Numeric identifier (May change!)"""
  id: Int!
  alignment(where: AlignmentWhereClause = null, orderBy: [AlignmentOrderByClause!] = []): Alignment
  alignmentId: Int!

  """z-index of the frame in the tiltseries"""
  zIndex: Int!

  """In-plane X-shift of the projection in angstrom"""
  xOffset: Float

  """In-plane Y-shift of the projection in angstrom"""
  yOffset: Float

  """X-axis rotation in degrees"""
  volumeXRotation: Float

  """In-plane rotation of the projection in degrees"""
  inPlaneRotation: [[Float!]!]

  """Tilt angle of the projection in degrees"""
  tiltAngle: Float
}

input PerSectionAlignmentParametersOrderByClause {
  alignment: AlignmentOrderByClause
  zIndex: orderBy
  xOffset: orderBy
  yOffset: orderBy
  volumeXRotation: orderBy
  inPlaneRotation: orderBy
  tiltAngle: orderBy
  id: orderBy
}

type PerSectionAlignmentParametersAggregate {
  aggregate: [PerSectionAlignmentParametersAggregateFunctions!]
}

type PerSectionAlignmentParametersAggregateFunctions {
  sum: PerSectionAlignmentParametersNumericalColumns
  avg: PerSectionAlignmentParametersNumericalColumns
  stddev: PerSectionAlignmentParametersNumericalColumns
  variance: PerSectionAlignmentParametersNumericalColumns
  min: PerSectionAlignmentParametersMinMaxColumns
  max: PerSectionAlignmentParametersMinMaxColumns
  groupBy: PerSectionAlignmentParametersGroupByOptions
  count(distinct: Boolean = false, columns: PerSectionAlignmentParametersCountColumns = null): Int
}

type PerSectionAlignmentParametersNumericalColumns {
  zIndex: Int
  xOffset: Float
  yOffset: Float
  volumeXRotation: Float
  tiltAngle: Float
  id: Int
}

type PerSectionAlignmentParametersMinMaxColumns {
  zIndex: Int
  xOffset: Float
  yOffset: Float
  volumeXRotation: Float
  tiltAngle: Float
  id: Int
}

type PerSectionAlignmentParametersGroupByOptions {
  alignment: AlignmentGroupByOptions
  zIndex: Int
  xOffset: Float
  yOffset: Float
  volumeXRotation: Float
  inPlaneRotation: [[Float!]!]
  tiltAngle: Float
  id: Int
}

enum PerSectionAlignmentParametersCountColumns {
  alignment
  zIndex
  xOffset
  yOffset
  volumeXRotation
  inPlaneRotation
  tiltAngle
  id
}

"""A connection to a list of items."""
type GainFileConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [GainFileEdge!]!
}

"""An edge in a connection."""
type GainFileEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: GainFile!
}

input GainFileOrderByClause {
  run: RunOrderByClause
  s3FilePath: orderBy
  httpsFilePath: orderBy
  id: orderBy
}

type GainFileAggregate {
  aggregate: [GainFileAggregateFunctions!]
}

type GainFileAggregateFunctions {
  sum: GainFileNumericalColumns
  avg: GainFileNumericalColumns
  stddev: GainFileNumericalColumns
  variance: GainFileNumericalColumns
  min: GainFileMinMaxColumns
  max: GainFileMinMaxColumns
  groupBy: GainFileGroupByOptions
  count(distinct: Boolean = false, columns: GainFileCountColumns = null): Int
}

type GainFileNumericalColumns {
  id: Int
}

type GainFileMinMaxColumns {
  s3FilePath: String
  httpsFilePath: String
  id: Int
}

type GainFileGroupByOptions {
  run: RunGroupByOptions
  s3FilePath: String
  httpsFilePath: String
  id: Int
}

enum GainFileCountColumns {
  run
  s3FilePath
  httpsFilePath
  id
}

"""A connection to a list of items."""
type FrameAcquisitionFileConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [FrameAcquisitionFileEdge!]!
}

"""An edge in a connection."""
type FrameAcquisitionFileEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: FrameAcquisitionFile!
}

"""
References to files containing more information about frame acquisition
"""
type FrameAcquisitionFile implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!

  """Numeric identifier (May change!)"""
  id: Int!
  run(where: RunWhereClause = null, orderBy: [RunOrderByClause!] = []): Run
  runId: Int

  """Path to the frame acquisition mdoc file in s3"""
  s3MdocPath: String!

  """Path to the frame acquisition mdoc file as an https url"""
  httpsMdocPath: String!
}

input FrameAcquisitionFileOrderByClause {
  run: RunOrderByClause
  s3MdocPath: orderBy
  httpsMdocPath: orderBy
  id: orderBy
}

type FrameAcquisitionFileAggregate {
  aggregate: [FrameAcquisitionFileAggregateFunctions!]
}

type FrameAcquisitionFileAggregateFunctions {
  sum: FrameAcquisitionFileNumericalColumns
  avg: FrameAcquisitionFileNumericalColumns
  stddev: FrameAcquisitionFileNumericalColumns
  variance: FrameAcquisitionFileNumericalColumns
  min: FrameAcquisitionFileMinMaxColumns
  max: FrameAcquisitionFileMinMaxColumns
  groupBy: FrameAcquisitionFileGroupByOptions
  count(distinct: Boolean = false, columns: FrameAcquisitionFileCountColumns = null): Int
}

type FrameAcquisitionFileNumericalColumns {
  id: Int
}

type FrameAcquisitionFileMinMaxColumns {
  s3MdocPath: String
  httpsMdocPath: String
  id: Int
}

type FrameAcquisitionFileGroupByOptions {
  run: RunGroupByOptions
  s3MdocPath: String
  httpsMdocPath: String
  id: Int
}

enum FrameAcquisitionFileCountColumns {
  run
  s3MdocPath
  httpsMdocPath
  id
}

"""A connection to a list of items."""
type TomogramVoxelSpacingConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [TomogramVoxelSpacingEdge!]!
}

"""An edge in a connection."""
type TomogramVoxelSpacingEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: TomogramVoxelSpacing!
}

type TomogramVoxelSpacingAggregate {
  aggregate: [TomogramVoxelSpacingAggregateFunctions!]
}

type TomogramVoxelSpacingAggregateFunctions {
  sum: TomogramVoxelSpacingNumericalColumns
  avg: TomogramVoxelSpacingNumericalColumns
  stddev: TomogramVoxelSpacingNumericalColumns
  variance: TomogramVoxelSpacingNumericalColumns
  min: TomogramVoxelSpacingMinMaxColumns
  max: TomogramVoxelSpacingMinMaxColumns
  groupBy: TomogramVoxelSpacingGroupByOptions
  count(distinct: Boolean = false, columns: TomogramVoxelSpacingCountColumns = null): Int
}

type TomogramVoxelSpacingNumericalColumns {
  voxelSpacing: Float
  id: Int
}

type TomogramVoxelSpacingMinMaxColumns {
  voxelSpacing: Float
  s3Prefix: String
  httpsPrefix: String
  id: Int
}

enum TomogramVoxelSpacingCountColumns {
  annotationFiles
  run
  tomograms
  voxelSpacing
  s3Prefix
  httpsPrefix
  id
}

input LimitOffsetClause {
  limit: Int
  offset: Int
}

type DepositionAggregate {
  aggregate: [DepositionAggregateFunctions!]
}

type DepositionAggregateFunctions {
  sum: DepositionNumericalColumns
  avg: DepositionNumericalColumns
  stddev: DepositionNumericalColumns
  variance: DepositionNumericalColumns
  min: DepositionMinMaxColumns
  max: DepositionMinMaxColumns
  groupBy: DepositionGroupByOptions
  count(distinct: Boolean = false, columns: DepositionCountColumns = null): Int
}

type DepositionNumericalColumns {
  id: Int
}

type DepositionMinMaxColumns {
  title: String
  description: String
  depositionPublications: String
  relatedDatabaseEntries: String
  depositionDate: DateTime
  releaseDate: DateTime
  lastModifiedDate: DateTime
  keyPhotoUrl: String
  keyPhotoThumbnailUrl: String
  id: Int
}

enum DepositionCountColumns {
  authors
  alignments
  annotations
  datasets
  frames
  tiltseries
  tomograms
  title
  description
  depositionTypes
  depositionPublications
  relatedDatabaseEntries
  depositionDate
  releaseDate
  lastModifiedDate
  keyPhotoUrl
  keyPhotoThumbnailUrl
  id
}

type Mutation {
  createGainFile(input: GainFileCreateInput!): GainFile!
  updateGainFile(input: GainFileUpdateInput!, where: GainFileWhereClauseMutations!): [GainFile!]!
  deleteGainFile(where: GainFileWhereClauseMutations!): [GainFile!]!
  createFrameAcquisitionFile(input: FrameAcquisitionFileCreateInput!): FrameAcquisitionFile!
  updateFrameAcquisitionFile(input: FrameAcquisitionFileUpdateInput!, where: FrameAcquisitionFileWhereClauseMutations!): [FrameAcquisitionFile!]!
  deleteFrameAcquisitionFile(where: FrameAcquisitionFileWhereClauseMutations!): [FrameAcquisitionFile!]!
  createAlignment(input: AlignmentCreateInput!): Alignment!
  updateAlignment(input: AlignmentUpdateInput!, where: AlignmentWhereClauseMutations!): [Alignment!]!
  deleteAlignment(where: AlignmentWhereClauseMutations!): [Alignment!]!
  createAnnotationAuthor(input: AnnotationAuthorCreateInput!): AnnotationAuthor!
  updateAnnotationAuthor(input: AnnotationAuthorUpdateInput!, where: AnnotationAuthorWhereClauseMutations!): [AnnotationAuthor!]!
  deleteAnnotationAuthor(where: AnnotationAuthorWhereClauseMutations!): [AnnotationAuthor!]!
  createAnnotationFile(input: AnnotationFileCreateInput!): AnnotationFile!
  updateAnnotationFile(input: AnnotationFileUpdateInput!, where: AnnotationFileWhereClauseMutations!): [AnnotationFile!]!
  deleteAnnotationFile(where: AnnotationFileWhereClauseMutations!): [AnnotationFile!]!
  createAnnotationShape(input: AnnotationShapeCreateInput!): AnnotationShape!
  updateAnnotationShape(input: AnnotationShapeUpdateInput!, where: AnnotationShapeWhereClauseMutations!): [AnnotationShape!]!
  deleteAnnotationShape(where: AnnotationShapeWhereClauseMutations!): [AnnotationShape!]!
  createAnnotation(input: AnnotationCreateInput!): Annotation!
  updateAnnotation(input: AnnotationUpdateInput!, where: AnnotationWhereClauseMutations!): [Annotation!]!
  deleteAnnotation(where: AnnotationWhereClauseMutations!): [Annotation!]!
  createDatasetAuthor(input: DatasetAuthorCreateInput!): DatasetAuthor!
  updateDatasetAuthor(input: DatasetAuthorUpdateInput!, where: DatasetAuthorWhereClauseMutations!): [DatasetAuthor!]!
  deleteDatasetAuthor(where: DatasetAuthorWhereClauseMutations!): [DatasetAuthor!]!
  createDatasetFunding(input: DatasetFundingCreateInput!): DatasetFunding!
  updateDatasetFunding(input: DatasetFundingUpdateInput!, where: DatasetFundingWhereClauseMutations!): [DatasetFunding!]!
  deleteDatasetFunding(where: DatasetFundingWhereClauseMutations!): [DatasetFunding!]!
  createDataset(input: DatasetCreateInput!): Dataset!
  updateDataset(input: DatasetUpdateInput!, where: DatasetWhereClauseMutations!): [Dataset!]!
  deleteDataset(where: DatasetWhereClauseMutations!): [Dataset!]!
  createDepositionAuthor(input: DepositionAuthorCreateInput!): DepositionAuthor!
  updateDepositionAuthor(input: DepositionAuthorUpdateInput!, where: DepositionAuthorWhereClauseMutations!): [DepositionAuthor!]!
  deleteDepositionAuthor(where: DepositionAuthorWhereClauseMutations!): [DepositionAuthor!]!
  createDeposition(input: DepositionCreateInput!): Deposition!
  updateDeposition(input: DepositionUpdateInput!, where: DepositionWhereClauseMutations!): [Deposition!]!
  deleteDeposition(where: DepositionWhereClauseMutations!): [Deposition!]!
  createDepositionType(input: DepositionTypeCreateInput!): DepositionType!
  updateDepositionType(input: DepositionTypeUpdateInput!, where: DepositionTypeWhereClauseMutations!): [DepositionType!]!
  deleteDepositionType(where: DepositionTypeWhereClauseMutations!): [DepositionType!]!
  createFrame(input: FrameCreateInput!): Frame!
  updateFrame(input: FrameUpdateInput!, where: FrameWhereClauseMutations!): [Frame!]!
  deleteFrame(where: FrameWhereClauseMutations!): [Frame!]!
  createPerSectionAlignmentParameters(input: PerSectionAlignmentParametersCreateInput!): PerSectionAlignmentParameters!
  updatePerSectionAlignmentParameters(input: PerSectionAlignmentParametersUpdateInput!, where: PerSectionAlignmentParametersWhereClauseMutations!): [PerSectionAlignmentParameters!]!
  deletePerSectionAlignmentParameters(where: PerSectionAlignmentParametersWhereClauseMutations!): [PerSectionAlignmentParameters!]!
  createRun(input: RunCreateInput!): Run!
  updateRun(input: RunUpdateInput!, where: RunWhereClauseMutations!): [Run!]!
  deleteRun(where: RunWhereClauseMutations!): [Run!]!
  createTiltseries(input: TiltseriesCreateInput!): Tiltseries!
  updateTiltseries(input: TiltseriesUpdateInput!, where: TiltseriesWhereClauseMutations!): [Tiltseries!]!
  deleteTiltseries(where: TiltseriesWhereClauseMutations!): [Tiltseries!]!
  createTomogramAuthor(input: TomogramAuthorCreateInput!): TomogramAuthor!
  updateTomogramAuthor(input: TomogramAuthorUpdateInput!, where: TomogramAuthorWhereClauseMutations!): [TomogramAuthor!]!
  deleteTomogramAuthor(where: TomogramAuthorWhereClauseMutations!): [TomogramAuthor!]!
  createTomogramVoxelSpacing(input: TomogramVoxelSpacingCreateInput!): TomogramVoxelSpacing!
  updateTomogramVoxelSpacing(input: TomogramVoxelSpacingUpdateInput!, where: TomogramVoxelSpacingWhereClauseMutations!): [TomogramVoxelSpacing!]!
  deleteTomogramVoxelSpacing(where: TomogramVoxelSpacingWhereClauseMutations!): [TomogramVoxelSpacing!]!
  createTomogram(input: TomogramCreateInput!): Tomogram!
  updateTomogram(input: TomogramUpdateInput!, where: TomogramWhereClauseMutations!): [Tomogram!]!
  deleteTomogram(where: TomogramWhereClauseMutations!): [Tomogram!]!
  createAnnotationMethodLink(input: AnnotationMethodLinkCreateInput!): AnnotationMethodLink!
  updateAnnotationMethodLink(input: AnnotationMethodLinkUpdateInput!, where: AnnotationMethodLinkWhereClauseMutations!): [AnnotationMethodLink!]!
  deleteAnnotationMethodLink(where: AnnotationMethodLinkWhereClauseMutations!): [AnnotationMethodLink!]!
}

input GainFileCreateInput {
  runId: ID!

  """Path to the file in s3"""
  s3FilePath: String!

  """Path to the file as an https url"""
  httpsFilePath: String!

  """Numeric identifier (May change!)"""
  id: Int!
}

input GainFileUpdateInput {
  runId: ID

  """Path to the file in s3"""
  s3FilePath: String

  """Path to the file as an https url"""
  httpsFilePath: String

  """Numeric identifier (May change!)"""
  id: Int
}

input GainFileWhereClauseMutations {
  id: IntComparators
}

input FrameAcquisitionFileCreateInput {
  runId: ID = null

  """Path to the frame acquisition mdoc file in s3"""
  s3MdocPath: String!

  """Path to the frame acquisition mdoc file as an https url"""
  httpsMdocPath: String!

  """Numeric identifier (May change!)"""
  id: Int!
}

input FrameAcquisitionFileUpdateInput {
  runId: ID = null

  """Path to the frame acquisition mdoc file in s3"""
  s3MdocPath: String

  """Path to the frame acquisition mdoc file as an https url"""
  httpsMdocPath: String

  """Numeric identifier (May change!)"""
  id: Int
}

input FrameAcquisitionFileWhereClauseMutations {
  id: IntComparators
}

input AlignmentCreateInput {
  depositionId: ID = null
  tiltseriesId: ID = null
  runId: ID = null

  """Whether this a LOCAL or GLOBAL alignment"""
  alignmentType: alignment_type_enum = null

  """The method used to create this alignment"""
  alignmentMethod: alignment_method_type_enum = null

  """X dimension of the reconstruction volume in angstrom"""
  volumeXDimension: Float = null

  """Y dimension of the reconstruction volume in angstrom"""
  volumeYDimension: Float = null

  """Z dimension of the reconstruction volume in angstrom"""
  volumeZDimension: Float = null

  """X shift of the reconstruction volume in angstrom"""
  volumeXOffset: Float = null

  """Y shift of the reconstruction volume in angstrom"""
  volumeYOffset: Float = null

  """Z shift of the reconstruction volume in angstrom"""
  volumeZOffset: Float = null

  """Additional X rotation of the reconstruction volume in degrees"""
  xRotationOffset: Float = null

  """Additional tilt offset in degrees"""
  tiltOffset: Float = null

  """A placeholder for the affine transformation matrix."""
  affineTransformationMatrix: String = null

  """S3 path to the metadata file for this alignment"""
  s3AlignmentMetadata: String = null

  """HTTPS url to the metadata file for this alignment"""
  httpsAlignmentMetadata: String = null

  """Whether this is the portal standard alignment"""
  isPortalStandard: Boolean = null

  """Numeric identifier (May change!)"""
  id: Int!
}

input AlignmentUpdateInput {
  depositionId: ID = null
  tiltseriesId: ID = null
  runId: ID = null

  """Whether this a LOCAL or GLOBAL alignment"""
  alignmentType: alignment_type_enum = null

  """The method used to create this alignment"""
  alignmentMethod: alignment_method_type_enum = null

  """X dimension of the reconstruction volume in angstrom"""
  volumeXDimension: Float = null

  """Y dimension of the reconstruction volume in angstrom"""
  volumeYDimension: Float = null

  """Z dimension of the reconstruction volume in angstrom"""
  volumeZDimension: Float = null

  """X shift of the reconstruction volume in angstrom"""
  volumeXOffset: Float = null

  """Y shift of the reconstruction volume in angstrom"""
  volumeYOffset: Float = null

  """Z shift of the reconstruction volume in angstrom"""
  volumeZOffset: Float = null

  """Additional X rotation of the reconstruction volume in degrees"""
  xRotationOffset: Float = null

  """Additional tilt offset in degrees"""
  tiltOffset: Float = null

  """A placeholder for the affine transformation matrix."""
  affineTransformationMatrix: String = null

  """S3 path to the metadata file for this alignment"""
  s3AlignmentMetadata: String = null

  """HTTPS url to the metadata file for this alignment"""
  httpsAlignmentMetadata: String = null

  """Whether this is the portal standard alignment"""
  isPortalStandard: Boolean = null

  """Numeric identifier (May change!)"""
  id: Int
}

input AlignmentWhereClauseMutations {
  id: IntComparators
}

input AnnotationAuthorCreateInput {
  """Reference to the annotation this author contributed to"""
  annotationId: ID = null

  """Numeric identifier (May change!)"""
  id: Int!

  """The order in which the author appears in the publication"""
  authorListOrder: Int!

  """A unique, persistent identifier for researchers, provided by ORCID."""
  orcid: String = null

  """Full name of an annotation author (e.g. Jane Doe)."""
  name: String!

  """Email address for this author"""
  email: String = null

  """
  Name of the institution an annotator is affiliated with. Sometimes, one annotator may have multiple affiliations.
  """
  affiliationName: String = null

  """Address of the institution an annotator is affiliated with."""
  affiliationAddress: String = null

  """
  A unique identifier assigned to the affiliated institution by The Research Organization Registry (ROR).
  """
  affiliationIdentifier: String = null

  """Indicates whether an annotator is the corresponding author"""
  correspondingAuthorStatus: Boolean = null

  """
  Indicates whether an author is the main person executing the annotation, especially on manual annotation
  """
  primaryAuthorStatus: Boolean = null
}

input AnnotationAuthorUpdateInput {
  """Reference to the annotation this author contributed to"""
  annotationId: ID = null

  """Numeric identifier (May change!)"""
  id: Int

  """The order in which the author appears in the publication"""
  authorListOrder: Int

  """A unique, persistent identifier for researchers, provided by ORCID."""
  orcid: String = null

  """Full name of an annotation author (e.g. Jane Doe)."""
  name: String

  """Email address for this author"""
  email: String = null

  """
  Name of the institution an annotator is affiliated with. Sometimes, one annotator may have multiple affiliations.
  """
  affiliationName: String = null

  """Address of the institution an annotator is affiliated with."""
  affiliationAddress: String = null

  """
  A unique identifier assigned to the affiliated institution by The Research Organization Registry (ROR).
  """
  affiliationIdentifier: String = null

  """Indicates whether an annotator is the corresponding author"""
  correspondingAuthorStatus: Boolean = null

  """
  Indicates whether an author is the main person executing the annotation, especially on manual annotation
  """
  primaryAuthorStatus: Boolean = null
}

input AnnotationAuthorWhereClauseMutations {
  id: IntComparators
}

input AnnotationFileCreateInput {
  """Tiltseries Alignment"""
  alignmentId: ID = null

  """Shapes associated with an annotation"""
  annotationShapeId: ID = null

  """Voxel spacing that this annotation file is associated with"""
  tomogramVoxelSpacingId: ID = null

  """File format for this file"""
  format: String!

  """s3 path of the annotation file"""
  s3Path: String!

  """HTTPS path for this annotation file"""
  httpsPath: String!

  """
  Data curator’s subjective choice of default annotation to display in visualization for an object
  """
  isVisualizationDefault: Boolean = null

  """
  The source type for the annotation file (dataset_author, community, or portal_standard)
  """
  source: annotation_file_source_enum = null

  """Numeric identifier (May change!)"""
  id: Int!
}

input AnnotationFileUpdateInput {
  """Tiltseries Alignment"""
  alignmentId: ID = null

  """Shapes associated with an annotation"""
  annotationShapeId: ID = null

  """Voxel spacing that this annotation file is associated with"""
  tomogramVoxelSpacingId: ID = null

  """File format for this file"""
  format: String

  """s3 path of the annotation file"""
  s3Path: String

  """HTTPS path for this annotation file"""
  httpsPath: String

  """
  Data curator’s subjective choice of default annotation to display in visualization for an object
  """
  isVisualizationDefault: Boolean = null

  """
  The source type for the annotation file (dataset_author, community, or portal_standard)
  """
  source: annotation_file_source_enum = null

  """Numeric identifier (May change!)"""
  id: Int
}

input AnnotationFileWhereClauseMutations {
  id: IntComparators
}

input AnnotationShapeCreateInput {
  """Metadata about an shapes for an annotation"""
  annotationId: ID = null

  """
  The shape of the annotation (SegmentationMask, OrientedPoint, Point, InstanceSegmentation, Mesh)
  """
  shapeType: annotation_file_shape_type_enum = null

  """Numeric identifier (May change!)"""
  id: Int!
}

input AnnotationShapeUpdateInput {
  """Metadata about an shapes for an annotation"""
  annotationId: ID = null

  """
  The shape of the annotation (SegmentationMask, OrientedPoint, Point, InstanceSegmentation, Mesh)
  """
  shapeType: annotation_file_shape_type_enum = null

  """Numeric identifier (May change!)"""
  id: Int
}

input AnnotationShapeWhereClauseMutations {
  id: IntComparators
}

input AnnotationCreateInput {
  runId: ID = null
  depositionId: ID = null

  """S3 path for the metadata json file for this annotation"""
  s3MetadataPath: String!

  """HTTPS path for the metadata json file for this annotation"""
  httpsMetadataPath: String!

  """
  DOIs for publications that describe the dataset. Use a comma to separate multiple DOIs.
  """
  annotationPublication: String = null

  """
  Describe how the annotation is made (e.g. Manual, crYoLO, Positive Unlabeled Learning, template matching)
  """
  annotationMethod: String!

  """
  Whether an annotation is considered ground truth, as determined by the annotator.
  """
  groundTruthStatus: Boolean = null

  """
  Gene Ontology Cellular Component identifier or UniProtKB accession for the annotation object.
  """
  objectId: String!

  """
  Name of the object being annotated (e.g. ribosome, nuclear pore complex, actin filament, membrane)
  """
  objectName: String!

  """
  A textual description of the annotation object, can be a longer description to include additional information not covered by the Annotation object name and state.
  """
  objectDescription: String = null

  """Molecule state annotated (e.g. open, closed)"""
  objectState: String = null

  """Number of objects identified"""
  objectCount: Int = null

  """
  Describe the confidence level of the annotation. Precision is defined as the % of annotation objects being true positive
  """
  confidencePrecision: Float = null

  """
  Describe the confidence level of the annotation. Recall is defined as the % of true positives being annotated correctly
  """
  confidenceRecall: Float = null

  """Annotation filename used as ground truth for precision and recall"""
  groundTruthUsed: String = null

  """Software used for generating this annotation"""
  annotationSoftware: String = null

  """
  Data curator’s subjective choice as the best annotation of the same annotation object ID
  """
  isCuratorRecommended: Boolean = null

  """
  The method type for generating the annotation (e.g. manual, hybrid, automated)
  """
  methodType: annotation_method_type_enum!

  """Date when an annotation set is initially received by the Data Portal."""
  depositionDate: DateTime!

  """Date when annotation data is made public by the Data Portal."""
  releaseDate: DateTime!

  """Date when an annotation was last modified in the Data Portal"""
  lastModifiedDate: DateTime!

  """Numeric identifier (May change!)"""
  id: Int!
}

input AnnotationUpdateInput {
  runId: ID = null
  depositionId: ID = null

  """S3 path for the metadata json file for this annotation"""
  s3MetadataPath: String

  """HTTPS path for the metadata json file for this annotation"""
  httpsMetadataPath: String

  """
  DOIs for publications that describe the dataset. Use a comma to separate multiple DOIs.
  """
  annotationPublication: String = null

  """
  Describe how the annotation is made (e.g. Manual, crYoLO, Positive Unlabeled Learning, template matching)
  """
  annotationMethod: String

  """
  Whether an annotation is considered ground truth, as determined by the annotator.
  """
  groundTruthStatus: Boolean = null

  """
  Gene Ontology Cellular Component identifier or UniProtKB accession for the annotation object.
  """
  objectId: String

  """
  Name of the object being annotated (e.g. ribosome, nuclear pore complex, actin filament, membrane)
  """
  objectName: String

  """
  A textual description of the annotation object, can be a longer description to include additional information not covered by the Annotation object name and state.
  """
  objectDescription: String = null

  """Molecule state annotated (e.g. open, closed)"""
  objectState: String = null

  """Number of objects identified"""
  objectCount: Int = null

  """
  Describe the confidence level of the annotation. Precision is defined as the % of annotation objects being true positive
  """
  confidencePrecision: Float = null

  """
  Describe the confidence level of the annotation. Recall is defined as the % of true positives being annotated correctly
  """
  confidenceRecall: Float = null

  """Annotation filename used as ground truth for precision and recall"""
  groundTruthUsed: String = null

  """Software used for generating this annotation"""
  annotationSoftware: String = null

  """
  Data curator’s subjective choice as the best annotation of the same annotation object ID
  """
  isCuratorRecommended: Boolean = null

  """
  The method type for generating the annotation (e.g. manual, hybrid, automated)
  """
  methodType: annotation_method_type_enum

  """Date when an annotation set is initially received by the Data Portal."""
  depositionDate: DateTime

  """Date when annotation data is made public by the Data Portal."""
  releaseDate: DateTime

  """Date when an annotation was last modified in the Data Portal"""
  lastModifiedDate: DateTime

  """Numeric identifier (May change!)"""
  id: Int
}

input AnnotationWhereClauseMutations {
  id: IntComparators
}

input DatasetAuthorCreateInput {
  """Dataset authored by this person"""
  datasetId: ID = null

  """Numeric identifier (May change!)"""
  id: Int!

  """The order in which the author appears in the publication"""
  authorListOrder: Int!

  """A unique, persistent identifier for researchers, provided by ORCID."""
  orcid: String = null

  """Full name of an author (e.g. Jane Doe)."""
  name: String!

  """Email address for this author"""
  email: String = null

  """Name of the institutions an author is affiliated with. Comma separated"""
  affiliationName: String = null

  """Address of the institution an author is affiliated with."""
  affiliationAddress: String = null

  """
  A unique identifier assigned to the affiliated institution by The Research Organization Registry (ROR).
  """
  affiliationIdentifier: String = null

  """Indicates whether an author is the corresponding author"""
  correspondingAuthorStatus: Boolean = null

  """
  Indicates whether an author is the main person associated with the corresponding dataset
  """
  primaryAuthorStatus: Boolean = null
}

input DatasetAuthorUpdateInput {
  """Dataset authored by this person"""
  datasetId: ID = null

  """Numeric identifier (May change!)"""
  id: Int

  """The order in which the author appears in the publication"""
  authorListOrder: Int

  """A unique, persistent identifier for researchers, provided by ORCID."""
  orcid: String = null

  """Full name of an author (e.g. Jane Doe)."""
  name: String

  """Email address for this author"""
  email: String = null

  """Name of the institutions an author is affiliated with. Comma separated"""
  affiliationName: String = null

  """Address of the institution an author is affiliated with."""
  affiliationAddress: String = null

  """
  A unique identifier assigned to the affiliated institution by The Research Organization Registry (ROR).
  """
  affiliationIdentifier: String = null

  """Indicates whether an author is the corresponding author"""
  correspondingAuthorStatus: Boolean = null

  """
  Indicates whether an author is the main person associated with the corresponding dataset
  """
  primaryAuthorStatus: Boolean = null
}

input DatasetAuthorWhereClauseMutations {
  id: IntComparators
}

input DatasetFundingCreateInput {
  """The dataset this dataset funding is a part of"""
  datasetId: ID = null

  """Name of the funding agency."""
  fundingAgencyName: String = null

  """Grant identifier provided by the funding agency."""
  grantId: String = null

  """Numeric identifier (May change!)"""
  id: Int!
}

input DatasetFundingUpdateInput {
  """The dataset this dataset funding is a part of"""
  datasetId: ID = null

  """Name of the funding agency."""
  fundingAgencyName: String = null

  """Grant identifier provided by the funding agency."""
  grantId: String = null

  """Numeric identifier (May change!)"""
  id: Int
}

input DatasetFundingWhereClauseMutations {
  id: IntComparators
}

input DatasetCreateInput {
  """Reference to the deposition this dataset is associated with"""
  depositionId: ID!

  """Title of a CryoET dataset"""
  title: String!

  """
  A short description of a CryoET dataset, similar to an abstract for a journal article or dataset.
  """
  description: String!

  """
  Name of the organism from which a biological sample used in a CryoET study is derived from, e.g. homo sapiens
  """
  organismName: String = null

  """NCBI taxonomy identifier for the organism, e.g. 9606"""
  organismTaxid: Int = null

  """
  Name of the tissue from which a biological sample used in a CryoET study is derived from.
  """
  tissueName: String = null

  """UBERON identifier for the tissue"""
  tissueId: String = null

  """
  Name of the cell from which a biological sample used in a CryoET study is derived from.
  """
  cellName: String = null

  """Cell Ontology identifier for the cell type"""
  cellTypeId: String = null

  """Cell line or strain for the sample."""
  cellStrainName: String = null

  """Link to more information about the cell strain"""
  cellStrainId: String = null

  """
  Type of samples used in a CryoET study. (cell, tissue, organism, intact organelle, in-vitro mixture, in-silico synthetic data, other)
  """
  sampleType: sample_type_enum = null

  """Describe how the sample was prepared."""
  samplePreparation: String = null

  """Describe Cryo-ET grid preparation."""
  gridPreparation: String = null

  """
  Describe other setup not covered by sample preparation or grid preparation that may make this dataset unique in the same publication
  """
  otherSetup: String = null

  """URL for the dataset preview image."""
  keyPhotoUrl: String = null

  """URL for the thumbnail of preview image."""
  keyPhotoThumbnailUrl: String = null

  """Name of the cellular component"""
  cellComponentName: String = null

  """
  If the dataset focuses on a specific part of a cell, the subset is included here
  """
  cellComponentId: String = null

  """Date when a dataset is initially received by the Data Portal."""
  depositionDate: DateTime!

  """Date when a dataset is made available on the Data Portal."""
  releaseDate: DateTime!

  """Date when a released dataset is last modified."""
  lastModifiedDate: DateTime!

  """
  Comma-separated list of DOIs for publications associated with the dataset.
  """
  datasetPublications: String = null

  """
  If a CryoET dataset is also deposited into another database, enter the database identifier here (e.g. EMPIAR-11445). Use a comma to separate multiple identifiers.
  """
  relatedDatabaseEntries: String = null

  """The S3 public bucket path where this dataset is contained"""
  s3Prefix: String!

  """The https directory path where this dataset is contained"""
  httpsPrefix: String!

  """
  An identifier for a CryoET dataset, assigned by the Data Portal. Used to identify the dataset as the directory name in data tree
  """
  id: Int!
}

input DatasetUpdateInput {
  """Reference to the deposition this dataset is associated with"""
  depositionId: ID

  """Title of a CryoET dataset"""
  title: String

  """
  A short description of a CryoET dataset, similar to an abstract for a journal article or dataset.
  """
  description: String

  """
  Name of the organism from which a biological sample used in a CryoET study is derived from, e.g. homo sapiens
  """
  organismName: String = null

  """NCBI taxonomy identifier for the organism, e.g. 9606"""
  organismTaxid: Int = null

  """
  Name of the tissue from which a biological sample used in a CryoET study is derived from.
  """
  tissueName: String = null

  """UBERON identifier for the tissue"""
  tissueId: String = null

  """
  Name of the cell from which a biological sample used in a CryoET study is derived from.
  """
  cellName: String = null

  """Cell Ontology identifier for the cell type"""
  cellTypeId: String = null

  """Cell line or strain for the sample."""
  cellStrainName: String = null

  """Link to more information about the cell strain"""
  cellStrainId: String = null

  """
  Type of samples used in a CryoET study. (cell, tissue, organism, intact organelle, in-vitro mixture, in-silico synthetic data, other)
  """
  sampleType: sample_type_enum = null

  """Describe how the sample was prepared."""
  samplePreparation: String = null

  """Describe Cryo-ET grid preparation."""
  gridPreparation: String = null

  """
  Describe other setup not covered by sample preparation or grid preparation that may make this dataset unique in the same publication
  """
  otherSetup: String = null

  """URL for the dataset preview image."""
  keyPhotoUrl: String = null

  """URL for the thumbnail of preview image."""
  keyPhotoThumbnailUrl: String = null

  """Name of the cellular component"""
  cellComponentName: String = null

  """
  If the dataset focuses on a specific part of a cell, the subset is included here
  """
  cellComponentId: String = null

  """Date when a dataset is initially received by the Data Portal."""
  depositionDate: DateTime

  """Date when a dataset is made available on the Data Portal."""
  releaseDate: DateTime

  """Date when a released dataset is last modified."""
  lastModifiedDate: DateTime

  """
  Comma-separated list of DOIs for publications associated with the dataset.
  """
  datasetPublications: String = null

  """
  If a CryoET dataset is also deposited into another database, enter the database identifier here (e.g. EMPIAR-11445). Use a comma to separate multiple identifiers.
  """
  relatedDatabaseEntries: String = null

  """The S3 public bucket path where this dataset is contained"""
  s3Prefix: String

  """The https directory path where this dataset is contained"""
  httpsPrefix: String

  """
  An identifier for a CryoET dataset, assigned by the Data Portal. Used to identify the dataset as the directory name in data tree
  """
  id: Int
}

input DatasetWhereClauseMutations {
  id: IntComparators
}

input DepositionAuthorCreateInput {
  depositionId: ID!

  """Numeric identifier (May change!)"""
  id: Int!

  """The order in which the author appears in the publication"""
  authorListOrder: Int!

  """A unique, persistent identifier for researchers, provided by ORCID."""
  orcid: String = null

  """Full name of a deposition author (e.g. Jane Doe)."""
  name: String!

  """Email address for this author"""
  email: String = null

  """Name of the institutions an author is affiliated with. Comma separated"""
  affiliationName: String = null

  """Address of the institution an author is affiliated with."""
  affiliationAddress: String = null

  """
  A unique identifier assigned to the affiliated institution by The Research Organization Registry (ROR).
  """
  affiliationIdentifier: String = null

  """Indicates whether an author is the corresponding author"""
  correspondingAuthorStatus: Boolean = null

  """Indicates whether an author is the main person creating the deposition"""
  primaryAuthorStatus: Boolean = null
}

input DepositionAuthorUpdateInput {
  depositionId: ID

  """Numeric identifier (May change!)"""
  id: Int

  """The order in which the author appears in the publication"""
  authorListOrder: Int

  """A unique, persistent identifier for researchers, provided by ORCID."""
  orcid: String = null

  """Full name of a deposition author (e.g. Jane Doe)."""
  name: String

  """Email address for this author"""
  email: String = null

  """Name of the institutions an author is affiliated with. Comma separated"""
  affiliationName: String = null

  """Address of the institution an author is affiliated with."""
  affiliationAddress: String = null

  """
  A unique identifier assigned to the affiliated institution by The Research Organization Registry (ROR).
  """
  affiliationIdentifier: String = null

  """Indicates whether an author is the corresponding author"""
  correspondingAuthorStatus: Boolean = null

  """Indicates whether an author is the main person creating the deposition"""
  primaryAuthorStatus: Boolean = null
}

input DepositionAuthorWhereClauseMutations {
  id: IntComparators
}

input DepositionCreateInput {
  """Title for the deposition"""
  title: String!

  """Description for the deposition"""
  description: String!

  """The publications related to this deposition"""
  depositionPublications: String = null

  """The related database entries to this deposition"""
  relatedDatabaseEntries: String = null

  """The date the deposition was deposited"""
  depositionDate: DateTime!

  """The date the deposition was released"""
  releaseDate: DateTime!

  """The date the deposition was last modified"""
  lastModifiedDate: DateTime!

  """URL for the deposition preview image."""
  keyPhotoUrl: String = null

  """URL for the deposition thumbnail image."""
  keyPhotoThumbnailUrl: String = null

  """Numeric identifier (May change!)"""
  id: Int!
}

input DepositionUpdateInput {
  """Title for the deposition"""
  title: String

  """Description for the deposition"""
  description: String

  """The publications related to this deposition"""
  depositionPublications: String = null

  """The related database entries to this deposition"""
  relatedDatabaseEntries: String = null

  """The date the deposition was deposited"""
  depositionDate: DateTime

  """The date the deposition was released"""
  releaseDate: DateTime

  """The date the deposition was last modified"""
  lastModifiedDate: DateTime

  """URL for the deposition preview image."""
  keyPhotoUrl: String = null

  """URL for the deposition thumbnail image."""
  keyPhotoThumbnailUrl: String = null

  """Numeric identifier (May change!)"""
  id: Int
}

input DepositionWhereClauseMutations {
  id: IntComparators
}

input DepositionTypeCreateInput {
  depositionId: ID!

  """
  The type of data submitted as a part of this deposition (annotation, dataset, tomogram)
  """
  type: deposition_types_enum = null

  """Numeric identifier (May change!)"""
  id: Int!
}

input DepositionTypeUpdateInput {
  depositionId: ID

  """
  The type of data submitted as a part of this deposition (annotation, dataset, tomogram)
  """
  type: deposition_types_enum = null

  """Numeric identifier (May change!)"""
  id: Int
}

input DepositionTypeWhereClauseMutations {
  id: IntComparators
}

input FrameCreateInput {
  depositionId: ID!
  runId: ID!

  """Camera angle for a frame"""
  rawAngle: Float = null

  """Frame's acquistion order within a tilt experiment"""
  acquisitionOrder: Int = null

  """The raw camera angle for a frame"""
  dose: Float = null

  """Whether this frame has been gain corrected"""
  isGainCorrected: Boolean = null

  """S3 path to the frame file"""
  s3FramePath: String!

  """HTTPS path to the frame file"""
  httpsFramePath: String!

  """Numeric identifier (May change!)"""
  id: Int!
}

input FrameUpdateInput {
  depositionId: ID
  runId: ID

  """Camera angle for a frame"""
  rawAngle: Float = null

  """Frame's acquistion order within a tilt experiment"""
  acquisitionOrder: Int = null

  """The raw camera angle for a frame"""
  dose: Float = null

  """Whether this frame has been gain corrected"""
  isGainCorrected: Boolean = null

  """S3 path to the frame file"""
  s3FramePath: String

  """HTTPS path to the frame file"""
  httpsFramePath: String

  """Numeric identifier (May change!)"""
  id: Int
}

input FrameWhereClauseMutations {
  id: IntComparators
}

input PerSectionAlignmentParametersCreateInput {
  """Tiltseries Alignment"""
  alignmentId: ID!

  """z-index of the frame in the tiltseries"""
  zIndex: Int!

  """In-plane X-shift of the projection in angstrom"""
  xOffset: Float = null

  """In-plane Y-shift of the projection in angstrom"""
  yOffset: Float = null

  """X-axis rotation in degrees"""
  volumeXRotation: Float = null

  """In-plane rotation of the projection in degrees"""
  inPlaneRotation: [[Float!]!] = null

  """Tilt angle of the projection in degrees"""
  tiltAngle: Float = null

  """Numeric identifier (May change!)"""
  id: Int!
}

input PerSectionAlignmentParametersUpdateInput {
  """Tiltseries Alignment"""
  alignmentId: ID

  """z-index of the frame in the tiltseries"""
  zIndex: Int

  """In-plane X-shift of the projection in angstrom"""
  xOffset: Float = null

  """In-plane Y-shift of the projection in angstrom"""
  yOffset: Float = null

  """X-axis rotation in degrees"""
  volumeXRotation: Float = null

  """In-plane rotation of the projection in degrees"""
  inPlaneRotation: [[Float!]!] = null

  """Tilt angle of the projection in degrees"""
  tiltAngle: Float = null

  """Numeric identifier (May change!)"""
  id: Int
}

input PerSectionAlignmentParametersWhereClauseMutations {
  id: IntComparators
}

input RunCreateInput {
  """Dataset that this run is a part of"""
  datasetId: ID!

  """Short name for this experiment run"""
  name: String!

  """The S3 public bucket path where this run is contained"""
  s3Prefix: String!

  """The HTTPS directory path where this run is contained url"""
  httpsPrefix: String!

  """Numeric identifier (May change!)"""
  id: Int!
}

input RunUpdateInput {
  """Dataset that this run is a part of"""
  datasetId: ID

  """Short name for this experiment run"""
  name: String

  """The S3 public bucket path where this run is contained"""
  s3Prefix: String

  """The HTTPS directory path where this run is contained url"""
  httpsPrefix: String

  """Numeric identifier (May change!)"""
  id: Int
}

input RunWhereClauseMutations {
  id: IntComparators
}

input TiltseriesCreateInput {
  runId: ID!
  depositionId: ID = null

  """S3 path to this tiltseries in multiscale OME-Zarr format"""
  s3OmezarrDir: String = null

  """S3 path to this tiltseries in MRC format (no scaling)"""
  s3MrcFile: String = null

  """HTTPS path to this tiltseries in multiscale OME-Zarr format"""
  httpsOmezarrDir: String = null

  """HTTPS path to this tiltseries in MRC format (no scaling)"""
  httpsMrcFile: String = null

  """S3 path to the angle list file for this tiltseries"""
  s3AngleList: String = null

  """HTTPS path to the angle list file for this tiltseries"""
  httpsAngleList: String = null

  """Electron Microscope Accelerator voltage in volts"""
  accelerationVoltage: Int!

  """Spherical Aberration Constant of the objective lens in millimeters"""
  sphericalAberrationConstant: Float!

  """Name of the microscope manufacturer (FEI, TFS, JEOL)"""
  microscopeManufacturer: tiltseries_microscope_manufacturer_enum!

  """Microscope model name"""
  microscopeModel: String!

  """Energy filter setup used"""
  microscopeEnergyFilter: String!

  """Phase plate configuration"""
  microscopePhasePlate: String = null

  """Image corrector setup"""
  microscopeImageCorrector: String = null

  """
  Other microscope optical setup information, in addition to energy filter, phase plate and image corrector
  """
  microscopeAdditionalInfo: String = null

  """Name of the camera manufacturer"""
  cameraManufacturer: String!

  """Camera model name"""
  cameraModel: String!

  """Minimal tilt angle in degrees"""
  tiltMin: Float!

  """Maximal tilt angle in degrees"""
  tiltMax: Float!

  """Total tilt range in degrees"""
  tiltRange: Float!

  """Tilt step in degrees"""
  tiltStep: Float!

  """The order of stage tilting during acquisition of the data"""
  tiltingScheme: String!

  """Rotation angle in degrees"""
  tiltAxis: Float!

  """
  Number of Electrons reaching the specimen in a square Angstrom area for the entire tilt series
  """
  totalFlux: Float!

  """Software used to collect data"""
  dataAcquisitionSoftware: String!

  """
  If a tilt series is deposited into EMPIAR, enter the EMPIAR dataset identifier
  """
  relatedEmpiarEntry: String = null

  """Describes the binning factor from frames to tilt series file"""
  binningFromFrames: Float = null

  """
  Author assessment of tilt series quality within the dataset (1-5, 5 is best)
  """
  tiltSeriesQuality: Int!

  """Whether this tilt series is aligned"""
  isAligned: Boolean!

  """Pixel spacing equal in both axes in angstroms"""
  pixelSpacing: Float!

  """Binning factor of the aligned tilt series"""
  alignedTiltseriesBinning: Int = null

  """Numeric identifier (May change!)"""
  id: Int!
}

input TiltseriesUpdateInput {
  runId: ID
  depositionId: ID = null

  """S3 path to this tiltseries in multiscale OME-Zarr format"""
  s3OmezarrDir: String = null

  """S3 path to this tiltseries in MRC format (no scaling)"""
  s3MrcFile: String = null

  """HTTPS path to this tiltseries in multiscale OME-Zarr format"""
  httpsOmezarrDir: String = null

  """HTTPS path to this tiltseries in MRC format (no scaling)"""
  httpsMrcFile: String = null

  """S3 path to the angle list file for this tiltseries"""
  s3AngleList: String = null

  """HTTPS path to the angle list file for this tiltseries"""
  httpsAngleList: String = null

  """Electron Microscope Accelerator voltage in volts"""
  accelerationVoltage: Int

  """Spherical Aberration Constant of the objective lens in millimeters"""
  sphericalAberrationConstant: Float

  """Name of the microscope manufacturer (FEI, TFS, JEOL)"""
  microscopeManufacturer: tiltseries_microscope_manufacturer_enum

  """Microscope model name"""
  microscopeModel: String

  """Energy filter setup used"""
  microscopeEnergyFilter: String

  """Phase plate configuration"""
  microscopePhasePlate: String = null

  """Image corrector setup"""
  microscopeImageCorrector: String = null

  """
  Other microscope optical setup information, in addition to energy filter, phase plate and image corrector
  """
  microscopeAdditionalInfo: String = null

  """Name of the camera manufacturer"""
  cameraManufacturer: String

  """Camera model name"""
  cameraModel: String

  """Minimal tilt angle in degrees"""
  tiltMin: Float

  """Maximal tilt angle in degrees"""
  tiltMax: Float

  """Total tilt range in degrees"""
  tiltRange: Float

  """Tilt step in degrees"""
  tiltStep: Float

  """The order of stage tilting during acquisition of the data"""
  tiltingScheme: String

  """Rotation angle in degrees"""
  tiltAxis: Float

  """
  Number of Electrons reaching the specimen in a square Angstrom area for the entire tilt series
  """
  totalFlux: Float

  """Software used to collect data"""
  dataAcquisitionSoftware: String

  """
  If a tilt series is deposited into EMPIAR, enter the EMPIAR dataset identifier
  """
  relatedEmpiarEntry: String = null

  """Describes the binning factor from frames to tilt series file"""
  binningFromFrames: Float = null

  """
  Author assessment of tilt series quality within the dataset (1-5, 5 is best)
  """
  tiltSeriesQuality: Int

  """Whether this tilt series is aligned"""
  isAligned: Boolean

  """Pixel spacing equal in both axes in angstroms"""
  pixelSpacing: Float

  """Binning factor of the aligned tilt series"""
  alignedTiltseriesBinning: Int = null

  """Numeric identifier (May change!)"""
  id: Int
}

input TiltseriesWhereClauseMutations {
  id: IntComparators
}

input TomogramAuthorCreateInput {
  """The tomogram this tomogram author is a part of"""
  tomogramId: ID = null

  """Numeric identifier (May change!)"""
  id: Int!

  """The order in which the author appears in the publication"""
  authorListOrder: Int!

  """A unique, persistent identifier for researchers, provided by ORCID."""
  orcid: String = null

  """Full name of an author (e.g. Jane Doe)."""
  name: String!

  """Email address for this author"""
  email: String = null

  """Name of the institutions an author is affiliated with. Comma separated"""
  affiliationName: String = null

  """Address of the institution an author is affiliated with."""
  affiliationAddress: String = null

  """
  A unique identifier assigned to the affiliated institution by The Research Organization Registry (ROR).
  """
  affiliationIdentifier: String = null

  """Indicates whether an author is the corresponding author"""
  correspondingAuthorStatus: Boolean = null

  """Indicates whether an author is the main person creating the tomogram"""
  primaryAuthorStatus: Boolean = null
}

input TomogramAuthorUpdateInput {
  """The tomogram this tomogram author is a part of"""
  tomogramId: ID = null

  """Numeric identifier (May change!)"""
  id: Int

  """The order in which the author appears in the publication"""
  authorListOrder: Int

  """A unique, persistent identifier for researchers, provided by ORCID."""
  orcid: String = null

  """Full name of an author (e.g. Jane Doe)."""
  name: String

  """Email address for this author"""
  email: String = null

  """Name of the institutions an author is affiliated with. Comma separated"""
  affiliationName: String = null

  """Address of the institution an author is affiliated with."""
  affiliationAddress: String = null

  """
  A unique identifier assigned to the affiliated institution by The Research Organization Registry (ROR).
  """
  affiliationIdentifier: String = null

  """Indicates whether an author is the corresponding author"""
  correspondingAuthorStatus: Boolean = null

  """Indicates whether an author is the main person creating the tomogram"""
  primaryAuthorStatus: Boolean = null
}

input TomogramAuthorWhereClauseMutations {
  id: IntComparators
}

input TomogramVoxelSpacingCreateInput {
  """The the run this tomogram voxel spacing is a part of"""
  runId: ID = null

  """The voxel spacing for the tomograms in this set in angstroms"""
  voxelSpacing: Float!

  """
  The S3 public bucket path where this tomogram voxel spacing is contained
  """
  s3Prefix: String!

  """
  The HTTPS directory path where this tomogram voxel spacing is contained
  """
  httpsPrefix: String!

  """Numeric identifier (May change!)"""
  id: Int!
}

input TomogramVoxelSpacingUpdateInput {
  """The the run this tomogram voxel spacing is a part of"""
  runId: ID = null

  """The voxel spacing for the tomograms in this set in angstroms"""
  voxelSpacing: Float

  """
  The S3 public bucket path where this tomogram voxel spacing is contained
  """
  s3Prefix: String

  """
  The HTTPS directory path where this tomogram voxel spacing is contained
  """
  httpsPrefix: String

  """Numeric identifier (May change!)"""
  id: Int
}

input TomogramVoxelSpacingWhereClauseMutations {
  id: IntComparators
}

input TomogramCreateInput {
  """Tiltseries Alignment"""
  alignmentId: ID = null

  """If the tomogram is part of a deposition, the related deposition"""
  depositionId: ID!
  runId: ID = null

  """Voxel spacings for a run"""
  tomogramVoxelSpacingId: ID = null

  """Short name for this tomogram"""
  name: String = null

  """Number of pixels in the 3D data fast axis"""
  sizeX: Int!

  """Number of pixels in the 3D data medium axis"""
  sizeY: Int!

  """
  Number of pixels in the 3D data slow axis.  This is the image projection direction at zero stage tilt
  """
  sizeZ: Int!

  """Voxel spacing equal in all three axes in angstroms"""
  voxelSpacing: Float!

  """
  Fiducial Alignment status: True = aligned with fiducial False = aligned without fiducial
  """
  fiducialAlignmentStatus: fiducial_alignment_status_enum!

  """Describe reconstruction method (WBP, SART, SIRT)"""
  reconstructionMethod: tomogram_reconstruction_method_enum!

  """Describe additional processing used to derive the tomogram"""
  processing: tomogram_processing_enum!

  """Version of tomogram"""
  tomogramVersion: Float = null

  """Processing software used to derive the tomogram"""
  processingSoftware: String = null

  """Name of software used for reconstruction"""
  reconstructionSoftware: String!

  """whether this tomogram adheres to portal standards"""
  isPortalStandard: Boolean = null

  """
  Whether this tomogram was submitted by the author of the dataset it belongs to.
  """
  isAuthorSubmitted: Boolean = null

  """
  Data curator’s subjective choice of default tomogram to display in visualization for a run
  """
  isVisualizationDefault: Boolean = null

  """S3 path to this tomogram in multiscale OME-Zarr format"""
  s3OmezarrDir: String = null

  """HTTPS path to this tomogram in multiscale OME-Zarr format"""
  httpsOmezarrDir: String = null

  """S3 path to this tomogram in MRC format (no scaling)"""
  s3MrcFile: String = null

  """HTTPS path to this tomogram in MRC format (no scaling)"""
  httpsMrcFile: String = null

  """comma separated x,y,z dimensions of the unscaled tomogram"""
  scale0Dimensions: String = null

  """comma separated x,y,z dimensions of the scale1 tomogram"""
  scale1Dimensions: String = null

  """comma separated x,y,z dimensions of the scale2 tomogram"""
  scale2Dimensions: String = null

  """Whether this tomogram is CTF corrected"""
  ctfCorrected: Boolean = null

  """x offset data relative to the canonical tomogram in pixels"""
  offsetX: Int!

  """y offset data relative to the canonical tomogram in pixels"""
  offsetY: Int!

  """z offset data relative to the canonical tomogram in pixels"""
  offsetZ: Int!

  """URL for the key photo"""
  keyPhotoUrl: String = null

  """URL for the thumbnail of key photo"""
  keyPhotoThumbnailUrl: String = null

  """the compact json of neuroglancer config"""
  neuroglancerConfig: String = null

  """
  Comma-separated list of DOIs for publications associated with the tomogram.
  """
  publications: String = null

  """
  If a CryoET tomogram is also deposited into another database, enter the database identifier here (e.g. EMPIAR-11445). Use a comma to separate multiple identifiers.
  """
  relatedDatabaseEntries: String = null

  """Numeric identifier (May change!)"""
  id: Int!

  """The date a data item was received by the cryoET data portal."""
  depositionDate: DateTime = null

  """The date a data item was received by the cryoET data portal."""
  releaseDate: DateTime = null

  """The date a piece of data was last modified on the cryoET data portal."""
  lastModifiedDate: DateTime = null
}

input TomogramUpdateInput {
  """Tiltseries Alignment"""
  alignmentId: ID = null

  """If the tomogram is part of a deposition, the related deposition"""
  depositionId: ID
  runId: ID = null

  """Voxel spacings for a run"""
  tomogramVoxelSpacingId: ID = null

  """Short name for this tomogram"""
  name: String = null

  """Number of pixels in the 3D data fast axis"""
  sizeX: Int

  """Number of pixels in the 3D data medium axis"""
  sizeY: Int

  """
  Number of pixels in the 3D data slow axis.  This is the image projection direction at zero stage tilt
  """
  sizeZ: Int

  """Voxel spacing equal in all three axes in angstroms"""
  voxelSpacing: Float

  """
  Fiducial Alignment status: True = aligned with fiducial False = aligned without fiducial
  """
  fiducialAlignmentStatus: fiducial_alignment_status_enum

  """Describe reconstruction method (WBP, SART, SIRT)"""
  reconstructionMethod: tomogram_reconstruction_method_enum

  """Describe additional processing used to derive the tomogram"""
  processing: tomogram_processing_enum

  """Version of tomogram"""
  tomogramVersion: Float = null

  """Processing software used to derive the tomogram"""
  processingSoftware: String = null

  """Name of software used for reconstruction"""
  reconstructionSoftware: String

  """whether this tomogram adheres to portal standards"""
  isPortalStandard: Boolean = null

  """
  Whether this tomogram was submitted by the author of the dataset it belongs to.
  """
  isAuthorSubmitted: Boolean = null

  """
  Data curator’s subjective choice of default tomogram to display in visualization for a run
  """
  isVisualizationDefault: Boolean = null

  """S3 path to this tomogram in multiscale OME-Zarr format"""
  s3OmezarrDir: String = null

  """HTTPS path to this tomogram in multiscale OME-Zarr format"""
  httpsOmezarrDir: String = null

  """S3 path to this tomogram in MRC format (no scaling)"""
  s3MrcFile: String = null

  """HTTPS path to this tomogram in MRC format (no scaling)"""
  httpsMrcFile: String = null

  """comma separated x,y,z dimensions of the unscaled tomogram"""
  scale0Dimensions: String = null

  """comma separated x,y,z dimensions of the scale1 tomogram"""
  scale1Dimensions: String = null

  """comma separated x,y,z dimensions of the scale2 tomogram"""
  scale2Dimensions: String = null

  """Whether this tomogram is CTF corrected"""
  ctfCorrected: Boolean = null

  """x offset data relative to the canonical tomogram in pixels"""
  offsetX: Int

  """y offset data relative to the canonical tomogram in pixels"""
  offsetY: Int

  """z offset data relative to the canonical tomogram in pixels"""
  offsetZ: Int

  """URL for the key photo"""
  keyPhotoUrl: String = null

  """URL for the thumbnail of key photo"""
  keyPhotoThumbnailUrl: String = null

  """the compact json of neuroglancer config"""
  neuroglancerConfig: String = null

  """
  Comma-separated list of DOIs for publications associated with the tomogram.
  """
  publications: String = null

  """
  If a CryoET tomogram is also deposited into another database, enter the database identifier here (e.g. EMPIAR-11445). Use a comma to separate multiple identifiers.
  """
  relatedDatabaseEntries: String = null

  """Numeric identifier (May change!)"""
  id: Int

  """The date a data item was received by the cryoET data portal."""
  depositionDate: DateTime = null

  """The date a data item was received by the cryoET data portal."""
  releaseDate: DateTime = null

  """The date a piece of data was last modified on the cryoET data portal."""
  lastModifiedDate: DateTime = null
}

input TomogramWhereClauseMutations {
  id: IntComparators
}

input AnnotationMethodLinkCreateInput {
  """Reference to annotation this link applies to"""
  annotationId: ID = null

  """Type of link (e.g. model, source code, documentation)"""
  linkType: annotation_method_link_type_enum!

  """user readable name of the resource"""
  name: String = null

  """URL to the resource"""
  link: String!

  """Numeric identifier (May change!)"""
  id: Int!
}

input AnnotationMethodLinkUpdateInput {
  """Reference to annotation this link applies to"""
  annotationId: ID = null

  """Type of link (e.g. model, source code, documentation)"""
  linkType: annotation_method_link_type_enum

  """user readable name of the resource"""
  name: String = null

  """URL to the resource"""
  link: String

  """Numeric identifier (May change!)"""
  id: Int
}

input AnnotationMethodLinkWhereClauseMutations {
  id: IntComparators
}
